<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rig Recovery</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.49.4/dist/umd/supabase.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #1c1f1c;
        }
        canvas {
            border: 1px solid #fff;
            background-color: grey;
        }
        #scoreDisplay, #speedDisplay, #leaderboard {
            font-family: 'Press Start 2P', sans-serif;
        }
        #leaderboardList {
            padding-left: 50px; /* Optional for better alignment */
        }
        #leaderboardList li {
            margin-bottom: 10px; /* Add 10px space between items */
        }
        #authModal {
            display: none;
            position: fixed;
            width: 300px; /* Fixed width for the modal */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #authModal h3 {
            margin: 0 0 10px 0;
        }
        #authModal input {
            display: block;
            margin-bottom: 10px;
            width: 100%;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="scoreDisplay" style="position: absolute; color: white; font-size: 16px;">Score: 0</div>
    <div id="speedDisplay" style="position: absolute; color: white; font-size: 16px;">Speed: 1</div>
    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <div id="leaderboard" style="position: absolute; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #1c1f1c; font-size: 14px; pointer-events: none; width: 400px; text-align: center; opacity: 0.5; z-index: 1;">
        <h3 style="text-align: center;">Leaderboard</h3>
        <ol id="leaderboardList" style="margin:0 auto; display: inline-block; text-align: left; padding-left: 1.5em;"></ol>
    </div>

    <button id="startButton" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; padding: 10px;">Start!</button>
    <button id="restartButton" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; padding: 10px;">Start!</button>

    <!-- Mobile-friendly arrow controls -->
    <div id="snakeControls" style="position: absolute; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; z-index: 10;">
        <div style="display: flex; justify-content: center;">
            <button id="snakeControlsButtonUp" aria-label="Up" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #eee;">▲</button>
        </div>
        <div style="display: flex; justify-content: center;">
            <button id="snakeControlsButtonLeft" aria-label="Left" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #eee;">◀</button>
            <div style="width: 60px; height: 60px; margin: 5px;"></div>
            <button id="snakeControlsButtonRight" aria-label="Right" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #eee;">▶</button>
        </div>
        <div style="display: flex; justify-content: center;">
            <button id="snakeControlsButtonDown" aria-label="Down" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #eee;">▼</button>
        </div>
    </div>

    <div id="authModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);">
        <h3 id="authModalTitle">Sign In/Sign Up</h3>
        <form id="authForm">
            <input type="email" id="email" placeholder="Email" required style="display: block; margin-bottom: 10px; width: 250px; padding: 10px;">
            <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
        </form>
        <!--<p style="margin-top: 10px; text-align: center;">
            <a href="#" id="toggleAuthMode" style="color: blue; text-decoration: underline;">Not a user? Sign up here.</a>
        </p>-->
    </div>

    <svg id="truckSVGold" data-name="truckSVGold" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" width="24" height="24" color="white" style="display: none;">
        <defs>
            <style>.cls-637b87aff95e86b59c57a1a5-1{fill:none;stroke:currentColor;stroke-miterlimit:10;}</style>
        </defs>
        <line class="cls-637b87aff95e86b59c57a1a5-1" x1="15.87" y1="17.8" x2="12" y2="17.8"></line>
        <polyline class="cls-637b87aff95e86b59c57a1a5-1" points="7.71 17.8 5.32 17.8 5.32 12.07 6.27 6.34 17.73 6.34 19.64 12.07 22.5 12.07 22.5 17.8 20.54 17.8"></polyline>
        <circle class="cls-637b87aff95e86b59c57a1a5-1" cx="18.2" cy="18.27" r="2.39"></circle>
        <circle class="cls-637b87aff95e86b59c57a1a5-1" cx="9.61" cy="18.27" r="2.39"></circle>
        <line class="cls-637b87aff95e86b59c57a1a5-1" x1="19.64" y1="12.07" x2="8.18" y2="12.07"></line>
        <line class="cls-637b87aff95e86b59c57a1a5-1" x1="12.95" y1="8.25" x2="12.95" y2="12.07"></line>
        <rect class="cls-637b87aff95e86b59c57a1a5-1" x="1.5" y="9.2" width="3.82" height="6.68" rx="1.91"></rect>
    </svg>

    <svg id="truckSVG" data-name="truckSVG" width="128pt" height="128pt" version="1.1" viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <path d="m118.4 60.289s-0.12891-5.8867-1.1523-7.5508c-1.0234-1.668-5.8867-4.0977-5.8867-4.0977s-0.51172-1.4062-3.1992-1.4062h-1.9219v-1.4062l-15.871-0.003906v1.4062l-28.031-0.12891h-19.328v-1.2812l-15.742 0.003907v1.2812h-16c-1.5352 0-3.7109 1.2812-3.7109 3.7109 0 1.4062-0.12891 2.1758-0.64063 3.5859-0.51562 1.1484-0.38672 2.1719-0.38672 3.1992v5.5039h-1.6641v3.0742h1.6641v5.5039c0 1.1523 0 2.1758 0.38281 3.1992 0.51172 1.2812 0.64062 2.1758 0.64062 3.5859 0 2.4336 2.3047 3.7109 3.7109 3.7109h16l0.003906 1.0195h15.871v-1.0234h19.328l28.031-0.12891v1.1523h15.742v-1.1523h1.9219c2.6875 0 3.1992-1.4062 3.1992-1.4062s4.8633-2.4336 5.8867-4.0977c1.0234-1.6641 1.1523-7.5508 1.1523-7.5508h0.64062v-8.707zm-60.285 2.0469h-46.336v-2.1758h46.336zm-0.12891-3.0703h-46.336v-2.1758h46.336zm-46.336-3.0742v-2.1758h14.336c0.76953 0.76953 1.6641 1.9219 2.9453 1.9219h11.137s1.6641 0.25781 3.457 0.25781zm46.336-3.0703h-9.3438c0.12891-0.76953 0.12891-1.5352 0-2.1758h9.3438zm0-3.5859v0.51172h-9.3438c0-0.25781-0.12891-0.51172-0.12891-0.51172zm-9.6016 4.4805h9.6016v2.1758h-14.207c1.5352 0 3.1992-0.25781 3.9688-0.89453 0.38281-0.25781 0.51172-0.76953 0.63672-1.2812zm-28.672-4.8633s0.25781 0.38281 0.64062 0.89453h-7.5508c2.3047-1.2773 6.9102-0.89453 6.9102-0.89453zm-7.8086 1.793h9.0898c0.25781 0.38281 0.51172 0.89453 0.64062 1.4062 0.12891 0.38281 0.38281 0.64063 0.64063 0.76953h-10.625v-1.2812c0-0.38281 0.12891-0.64062 0.25391-0.89453zm7.8086 29.312s-5.7617 0.38281-7.5508-1.4062h8.5742c-0.51172 0.89063-1.0234 1.4062-1.0234 1.4062zm1.9219-3.2031c-0.12891 0.25781-0.25781 0.64062-0.38281 0.89453l-9.6016 0.003906v-0.25781-1.793h13.824c-0.89844 0.25781-3.0742-0.63672-3.8398 1.1523zm36.352 2.8164h-9.4727s0.12891-0.38281 0.12891-1.0234h9.3438zm0-2.0469h-9.3438c0-0.64062 0-1.4062-0.12891-2.1758h9.4727zm0-3.0703h-9.8555c-0.12891-0.25781-0.25781-0.51172-0.51172-0.64062-1.5352-1.5352-7.6797-0.64062-7.6797-0.64062h-11.137c-1.0234 0-1.793 0.64062-2.4336 1.4062h-14.719v-2.1758h46.336zm0-3.0742h-46.336v-2.1758h46.336zm0-3.0703h-46.207v-2.1758h46.336zm0.12891-4.0977v1.0234h-46.336v-1.4062-0.76953h46.336zm4.9922 14.207c0 0.76953-0.64062 1.2812-1.2812 1.2812s-1.2812-0.64062-1.2812-1.2812v-28.285c0-0.76953 0.64062-1.2812 1.2812-1.2812s1.2812 0.64062 1.2812 1.2812zm16-7.293h-13.953v-1.6641h13.953zm0-11.906h-13.953v-1.6641h13.953zm17.277 6.7852h-0.38281c-0.38281 4.8633-1.5352 10.754-2.9453 13.184-1.6641 2.8164-10.113 2.0469-11.902 1.9219-1.793-0.12891 0-3.457 0.38281-6.5273 0.25781-2.0469 0.38281-6.0156 0.51172-8.4492h-0.51172v-4.2227h0.51172c-0.12891-2.5586-0.25781-5.8867-0.51172-7.6797-0.38281-3.0703-2.1758-6.3984-0.38281-6.5273 1.793-0.12891 10.238-0.89453 11.902 1.9219 1.2812 2.1758 2.4336 7.6797 2.8164 12.414h0.38281l0.003906 3.9648zm16.387 8.7031-16 2.9453v-1.0234l16.383-2.9453zm-16-22.656v-1.0234l16 2.9453 0.38281 1.0234z" fill="#fff"/>
    </svg>

    <script>
        const { createClient } = supabase
        const _supabase = createClient('https://qplxbyiotkuvsvganuhn.supabase.co', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFwbHhieWlvdGt1dnN2Z2FudWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTEwNTkwMTUsImV4cCI6MjA2NjYzNTAxNX0.NM4YbUhQmlqw9ugOBEYQLgVSlg2gR3RE-sTQKRXGSvk')
        console.log('Supabase client created:', _supabase);
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const speedDisplay = document.getElementById('speedDisplay');
        const leaderboardList = document.getElementById('leaderboardList');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const snakeControlsButtonUp = document.getElementById('snakeControlsButtonUp');
        const snakeControls = document.getElementById('snakeControls');
        const snakeControlsButtonDown = document.getElementById('snakeControlsButtonDown');
        const snakeControlsButtonLeft = document.getElementById('snakeControlsButtonLeft');
        const snakeControlsButtonRight = document.getElementById('snakeControlsButtonRight');

        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

let userName;
let snake, direction, food, gameOver, score, speed, interval;
let countdown = 0;
let countdownInterval = null;
let animProgress = 1;
let lastFrameTime = null;
let prevSnake = null;

// For the pop effect on the larger head
let headPopActive = false;
let headPopTimer = null;

let leaderboard = []; // Array to store leaderboard entries

// Each truck is an object: { x, y, color }
function randomTruckColor() {
    // Pick a random color for the truck body
    const colors = ['#e53935', '#43a047', '#1e88e5', '#fbc02d', '#8e24aa', '#f57c00', '#00acc1', '#6d4c41'];
    return colors[Math.floor(Math.random() * colors.length)];
}

function resetGame() {
    // Start with a single truck (the head)
    snake = [
        { x: 10, y: 10, color: '#00FF00' } // The player's truck is always bright green
    ];
    direction = { x: 1, y: 0 };
    food = generateFood();
    gameOver = false;
    score = 0;
    speed = 1;
    interval = 200;
    scoreDisplay.textContent = `Score: ${score}`;
    speedDisplay.textContent = `Speed: ${speed}`;
    restartButton.style.display = 'none';
    animProgress = 1;
    lastFrameTime = null;
    prevSnake = null;
    document.getElementById('leaderboard').style.opacity = 0.3;
}

function startGame() {
    resetGame();
    startButton.style.display = 'none';
    countdown = 3;
    draw();
    countdownInterval = setInterval(() => {
        countdown--;
        draw();
        if (countdown === 0) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            animProgress = 1;
            lastFrameTime = null;
            prevSnake = null;
            requestAnimationFrame(frameLoop);
        }
    }, 1000);
}



        function isMobile() {
            // Basic mobile detection
            return window.innerWidth <= 700 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function positionDisplays() {
            const gap = 10;
            const isMobileDevice = isMobile();
            // Center authModal over the game canvas on mobile
            const authModal = document.getElementById('authModal');
            const gameCanvas = document.getElementById('gameCanvas');
            if (isMobileDevice && authModal && gameCanvas) {
                console.log('Positioning auth modal for mobile');
                // Get canvas position and size
                const rect = gameCanvas.getBoundingClientRect();
                // Center modal over canvas
                authModal.style.position = 'absolute';
                authModal.style.left = (rect.left + rect.width / 2 + window.scrollX) + 'px';
                authModal.style.top = (rect.top + rect.height / 2 + window.scrollY) + 'px';
                authModal.style.transform = 'translate(-50%, -50%)';
                authModal.style.zIndex = '1000';
            } else if (authModal) {
                // Restore default (fixed, centered in viewport)
                authModal.style.position = 'fixed';
                authModal.style.left = '50%';
                authModal.style.top = '50%';
                authModal.style.transform = 'translate(-50%, -50%)';
                authModal.style.zIndex = '1000';
            }

            // Position start and restart buttons 20px above the bottom of the game canvas, centered horizontally, and ensure they are within the canvas
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            if (gameCanvas) {
                const rect = gameCanvas.getBoundingClientRect();
                // Calculate button width and height (fallback to 120x40 if not rendered yet)
                const buttonWidth = (startButton && startButton.offsetWidth) ? startButton.offsetWidth : 120;
                const buttonHeight = (startButton && startButton.offsetHeight) ? startButton.offsetHeight : 40;
                // Y position: 20px above the bottom, but not below the canvas
                const buttonY = rect.top + rect.height - 20 - buttonHeight + window.scrollY;
                // X position: center within the canvas
                const buttonX = rect.left + rect.width / 2 + window.scrollX;
                // Place start button
                if (startButton) {
                    startButton.style.position = 'absolute';
                    startButton.style.left = buttonX + 'px';
                    startButton.style.top = buttonY + 'px';
                    startButton.style.transform = 'translate(-50%, 0)';
                    startButton.style.zIndex = '1001';
                    // Ensure button is a child of the canvas's parent (so it overlays the canvas)
                    if (gameCanvas.parentNode && startButton.parentNode !== gameCanvas.parentNode) {
                        gameCanvas.parentNode.appendChild(startButton);
                    }
                }
                // Place restart button
                if (restartButton) {
                    restartButton.style.position = 'absolute';
                    restartButton.style.left = buttonX + 'px';
                    restartButton.style.top = buttonY + 'px';
                    restartButton.style.transform = 'translate(-50%, 0)';
                    restartButton.style.zIndex = '1001';
                    if (gameCanvas.parentNode && restartButton.parentNode !== gameCanvas.parentNode) {
                        gameCanvas.parentNode.appendChild(restartButton);
                    }
                }
            }
            const canvasRect = canvas.getBoundingClientRect();

            if (isMobileDevice) {
                console.log('Positioning displays for mobile');
                // Move all elements to the top of the page for mobile
                // Score: top right
                scoreDisplay.style.position = 'absolute';
                scoreDisplay.style.top = `${gap + window.scrollY}px`;
                scoreDisplay.style.left = `calc(100vw - ${scoreDisplay.offsetWidth + gap}px)`;

                // Speed: top left
                speedDisplay.style.position = 'absolute';
                speedDisplay.style.top = `${gap + window.scrollY}px`;
                speedDisplay.style.left = `${gap + window.scrollX}px`;

                // Move the game canvas to the top center of the page
                const gameCanvas = document.getElementById('gameCanvas');
                let canvasTop = gap + scoreDisplay.offsetHeight + gap + window.scrollY;
                if (gameCanvas) {
                    gameCanvas.style.position = 'absolute';
                    gameCanvas.style.top = `${canvasTop}px`;
                    gameCanvas.style.left = '50vw';
                    gameCanvas.style.transform = 'translateX(-50%)';
                }

                // Controls: just below the game canvas, centered
                if (snakeControls && gameCanvas) {
                    snakeControls.style.position = 'absolute';
                    snakeControls.style.top = `${canvasTop + gameCanvas.offsetHeight + gap}px`;
                    snakeControls.style.left = '50vw';
                    snakeControls.style.transform = 'translateX(-50%)';
                }

                // Leaderboard: centered inside the game canvas (overlay, under trucks)
                const leaderboard = document.getElementById('leaderboard');
                if (leaderboard && gameCanvas) {
                    // Insert leaderboard as a sibling after the canvas if not already
                    if (gameCanvas.nextSibling !== leaderboard) {
                        gameCanvas.parentNode.insertBefore(leaderboard, gameCanvas.nextSibling);
                    }
                    // Set leaderboard width and center both horizontally and vertically within the canvas
                    //const leaderboardWidth = Math.max(220, Math.floor(gameCanvas.width * 0.7));
                    const leaderboardWidth = '400';
                    leaderboard.style.position = 'absolute';
                    leaderboard.style.width = leaderboardWidth + 'px';
                    leaderboard.style.left = (gameCanvas.getBoundingClientRect().left + (gameCanvas.width - leaderboardWidth) / 2 + window.scrollX) + 'px';
                    // Vertically center: use flexbox on the leaderboard for content, but absolutely center the leaderboard itself
                    leaderboard.style.visibility = 'hidden';
                    leaderboard.style.display = 'block';
                    // Force reflow
                    void leaderboard.offsetHeight;
                    const verticalCenter = gameCanvas.getBoundingClientRect().top + (gameCanvas.height - leaderboard.offsetHeight) / 2 + window.scrollY;
                    leaderboard.style.top = `${verticalCenter}px`;
                    leaderboard.style.visibility = 'visible';
                    leaderboard.style.height = '400px';
                    leaderboard.style.opacity = '0.3';
                    leaderboard.style.pointerEvents = 'none';
                    leaderboard.style.textAlign = 'center';
                    leaderboard.style.zIndex = '0';
                }
            } else {
                // Desktop: original centered overlay logic
                // Score: right above canvas, right-aligned
                scoreDisplay.style.position = 'absolute';
                scoreDisplay.style.top = `${canvasRect.top - 25 + window.scrollY}px`;
                scoreDisplay.style.left = `${canvasRect.right - scoreDisplay.offsetWidth + window.scrollX}px`;
                // Speed: left above canvas, left-aligned
                speedDisplay.style.position = 'absolute';
                speedDisplay.style.top = `${canvasRect.top - 25 + window.scrollY}px`;
                speedDisplay.style.left = `${canvasRect.left + window.scrollX}px`;

                // Controls: just below the canvas, centered
                if (snakeControls) {
                    snakeControls.style.position = 'absolute';
                    snakeControls.style.top = `${canvasRect.bottom + 20 + window.scrollY}px`;
                    snakeControls.style.left = `${canvasRect.left + canvasRect.width / 2 + window.scrollX}px`;
                    snakeControls.style.transform = 'translateX(-50%)';
                }

                // Move leaderboard inside the canvas (centered overlay, under trucks)
                const leaderboard = document.getElementById('leaderboard');
                const gameCanvas = document.getElementById('gameCanvas');
                if (leaderboard && gameCanvas && gameCanvas.parentNode) {
                    // Insert leaderboard as a sibling after the canvas if not already
                    if (gameCanvas.nextSibling !== leaderboard) {
                        gameCanvas.parentNode.insertBefore(leaderboard, gameCanvas.nextSibling);
                    }
                    // Set leaderboard width and center both horizontally and vertically within the canvas
                    //const leaderboardWidth = Math.max(220, Math.floor(canvas.width * 0.7));
                    const leaderboardWidth = '400';
                    leaderboard.style.position = 'absolute';
                    leaderboard.style.width = leaderboardWidth + 'px';
                    leaderboard.style.height = '400px';
                    leaderboard.style.left = (canvasRect.left + (canvas.width - leaderboardWidth) / 2 + window.scrollX) + 'px';

                    // Vertically center: use flexbox on the leaderboard for content, but absolutely center the leaderboard itself
                    leaderboard.style.visibility = 'hidden';
                    leaderboard.style.display = 'block';
                    // Force reflow
                    void leaderboard.offsetHeight;
                    const verticalCenter = canvasRect.top + (canvasRect.height - leaderboard.offsetHeight) / 2 + window.scrollY;
                    leaderboard.style.top = `${verticalCenter}px`;
                    leaderboard.style.visibility = 'visible';

                    leaderboard.style.opacity = '0.3';
                    leaderboard.style.pointerEvents = 'none';
                    leaderboard.style.textAlign = 'center';
                    leaderboard.style.zIndex = '0';
                }
            }
        }
        

        window.addEventListener('resize', positionDisplays); // Reposition on window resize
        window.addEventListener('scroll', positionDisplays); // Reposition on scroll (for mobile)

        // Ensure all elements are rendered and styled before initial positioning
        window.addEventListener('DOMContentLoaded', () => {
            // Use a longer timeout and multiple calls to ensure layout is correct on mobile
            setTimeout(positionDisplays, 100);
            setTimeout(positionDisplays, 300);
            setTimeout(positionDisplays, 600);
            // Also call after all resources (images/fonts) are loaded
            window.addEventListener('load', () => {
                setTimeout(positionDisplays, 100);
                setTimeout(positionDisplays, 300);
                setTimeout(positionDisplays, 600);
            });
        });

function generateFood() {
    let newFood;
    let head = snake[0];
    // Predict the next head position
    let nextHead = { x: head.x + direction.x, y: head.y + direction.y };
    do {
        newFood = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount), color: randomTruckColor() };
    } while (
        snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
        (nextHead.x === newFood.x && nextHead.y === newFood.y)
    );
    return newFood;
}


        let floatingText = null; // Store the floating text object
let floatingTextTimer = null; // Timer to remove the floating text

function drawFloatingText() {
    if (!floatingText) return;

    const { x, y, opacity } = floatingText;

    ctx.save();
    ctx.globalAlpha = opacity; // Set transparency

    // Draw white outline
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 5;
    ctx.font = '20px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.strokeText('+1', x, y);

    // Draw purple fill
    ctx.fillStyle = 'purple';
    ctx.fillText('+1', x, y);

    ctx.restore();
}

function updateFloatingText() {
    if (!floatingText) return;

    // Smoothly move the text upward using interpolation
    floatingText.progress += 0.1; // Increment progress (adjust speed as needed)

    // Interpolate position based on progress
    floatingText.y = floatingText.startY + (floatingText.targetY - floatingText.startY) * floatingText.progress;

    // Fade out the text based on progress
    floatingText.opacity = 1.0 - floatingText.progress;

    // Remove the floating text when it reaches the target or becomes invisible
    if (floatingText.progress >= 1.0) {
        floatingText = null;
        clearTimeout(floatingTextTimer);
    }
}

// Draw a truck as a top view: colored rectangle, white cab at the front, and four wheels at the corners
function drawTruck(x, y, color, angle = 0) {
    const px = x * gridSize;
    const py = y * gridSize;

    ctx.save();
    ctx.translate(px + gridSize / 2, py + gridSize / 2);
    // Always orient the cab/windshield to the right (0 radians)
    ctx.rotate(angle);
    ctx.translate(-gridSize / 2, -gridSize / 2);


    // --- Draw main rectangle body ---
    ctx.save();
    ctx.globalAlpha = 1.0; // Make trucks fully opaque
    ctx.fillStyle = color;
    ctx.strokeStyle = shadeColor(color, -40);
    ctx.lineWidth = 2;
    const bodyW = gridSize * 0.96;
    const bodyH = gridSize * 0.6;
    const bodyX = (gridSize - bodyW) / 2;
    const bodyY = (gridSize - bodyH) / 2;

    // --- Draw tires: black squares at each corner, sticking out and UNDER the body ---
    ctx.save();
    ctx.fillStyle = '#111';
    const tireSize = gridSize * 0.25;
    // Offset so tires stick out from all four corners
    const offset = tireSize * 0.8;
    // Top left
    ctx.fillRect(bodyX - offset  + 3, bodyY - offset, tireSize, tireSize);
    // Top right (move left 5px)
    ctx.fillRect(bodyX + bodyW - tireSize + offset - 5, bodyY - offset, tireSize, tireSize);
    // Bottom left
    ctx.fillRect(bodyX - offset + 3, bodyY + bodyH - tireSize + offset, tireSize, tireSize);
    // Bottom right (move left 5px)
    ctx.fillRect(bodyX + bodyW - tireSize + offset - 5, bodyY + bodyH - tireSize + offset, tireSize, tireSize);
    ctx.restore();

    // Draw the truck body rectangle ON TOP of the tires, with rounded top right and bottom right corners
    ctx.beginPath();
    const r = Math.min(bodyW, bodyH) * 0.35; // radius for right corners
    ctx.moveTo(bodyX, bodyY); // top left
    ctx.lineTo(bodyX + bodyW - r, bodyY); // top edge to before top right
    ctx.quadraticCurveTo(bodyX + bodyW, bodyY, bodyX + bodyW, bodyY + r); // round top right
    ctx.lineTo(bodyX + bodyW, bodyY + bodyH - r); // right edge
    ctx.quadraticCurveTo(bodyX + bodyW, bodyY + bodyH, bodyX + bodyW - r, bodyY + bodyH); // round bottom right
    ctx.lineTo(bodyX, bodyY + bodyH); // bottom edge
    ctx.lineTo(bodyX, bodyY); // left edge
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    ctx.restore();
}

// Helper: draw a rounded rectangle
function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
}

// Helper: lighten/darken color by percent
function shadeColor(color, percent) {
    // color: #rrggbb
    let R = parseInt(color.substring(1,3),16);
    let G = parseInt(color.substring(3,5),16);
    let B = parseInt(color.substring(5,7),16);
    R = Math.min(255, Math.max(0, R + Math.round(2.55 * percent)));
    G = Math.min(255, Math.max(0, G + Math.round(2.55 * percent)));
    B = Math.min(255, Math.max(0, B + Math.round(2.55 * percent)));
    return `#${(R.toString(16)).padStart(2,'0')}${(G.toString(16)).padStart(2,'0')}${(B.toString(16)).padStart(2,'0')}`;
}

// Helper to get angle for truck based on direction (no mirroring)
function getTruckDrawAngle(dir) {
    // Truck points right by default
    if (dir.x === 1 && dir.y === 0) return 0; // right
    if (dir.x === 0 && dir.y === -1) return -Math.PI / 2; // up
    if (dir.x === 0 && dir.y === 1) return Math.PI / 2; // down
    if (dir.x === -1 && dir.y === 0) return Math.PI; // left
    return 0;
}

        function draw() {
            // Draw background
            ctx.fillStyle = 'grey';// Light gray background
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw countdown if active
            if (countdown > 0) {
                ctx.fillStyle = 'purple';
                ctx.font = `${Math.floor(canvas.width * 0.8)}px 'Press Start 2P', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = 0.85;
                ctx.fillText(countdown, canvas.width / 2, canvas.height / 2);
                ctx.globalAlpha = 1.0;
                return;
            }




            // Draw the food truck only if it is not hidden by the snake's head
            if (!(snake[0].x === food.x && snake[0].y === food.y)) {
                drawTruck(food.x, food.y, food.color, 0);
            }

            // Draw all trucks in the snake (head + collected trucks)
            const spacing = 0.18; // space between trucks in grid units (0.18*gridSize ~ 3.6px if gridSize=20)
            for (let i = 0; i < snake.length; i++) {
                let seg = snake[i];
                let prevSeg = prevSnake && prevSnake[i] ? prevSnake[i] : seg;
                // Interpolate position for smooth movement
                let x = (prevSeg.x + (seg.x - prevSeg.x) * animProgress);
                let y = (prevSeg.y + (seg.y - prevSeg.y) * animProgress);
                // Offset each truck by spacing * its index, in the direction opposite to its movement
                let angle = 0;
                let offsetX = 0, offsetY = 0;
                if (i === 0) {
                    angle = getTruckDrawAngle(direction);
                    offsetX = -direction.x * spacing * i;
                    offsetY = -direction.y * spacing * i;
                } else {
                    let prev = snake[i - 1];
                    let dx = prev.x - seg.x;
                    let dy = prev.y - seg.y;
                    angle = getTruckDrawAngle({ x: dx, y: dy });
                    // Normalize dx/dy to -1,0,1
                    if (dx !== 0) dx = dx > 0 ? 1 : -1;
                    if (dy !== 0) dy = dy > 0 ? 1 : -1;
                    offsetX = -dx * spacing * i;
                    offsetY = -dy * spacing * i;
                }
                drawTruck(x + offsetX, y + offsetY, seg.color, angle);
            }

            // Draw floating text
            drawFloatingText();

            // If game over, overlay game over text and submit score
            if (gameOver) {
                document.getElementById('leaderboard').style.opacity = 0.7;
                document.getElementById('leaderboard').style.zIndex = '2';
                document.getElementById('leaderboard').style.backgroundColor = 'grey';// Light background for contrast
                ctx.fillStyle = 'red';
                ctx.font = '20px "Press Start 2P"';
                ctx.zIndex = '1005';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height - 90);
                submitScore(score);
                restartButton.style.display = 'block';
                return;
            }
        }

        async function fetchLeaderboard() {
            const { data, error } = await _supabase
                .from('leaderboard')
                .select('name, score')
                .order('score', { ascending: false })
                .limit(10);

            if (error) {
                console.error('Error fetching leaderboard:', error);
                return [];
            }

            return data;
        }

        async function submitScore(score) {
            const { data: { user } } = await _supabase.auth.getUser();
            if (!user) {
                console.error('Error fetching user:', error);
                return;
            }
            //console.log("user.user_metadata: ", user);
            //const name = "TEST"; // Default name for testing purposes
            //const name = user.user_metadata.name; // Get the user's name from metadata
            const { error: insertError } = await _supabase
                .from('leaderboard')
                .insert({ score: score, name: userName, memid: user.id })
                .select();

            if (insertError) {
                console.error('Error submitting score:', insertError);
            } else {
                updateLeaderboardUI(); // Refresh leaderboard after submission
            }
        }

        async function updateLeaderboardUI() {
            const leaderboard = await fetchLeaderboard();
            leaderboardList.innerHTML = ''; // Clear existing leaderboard
            leaderboard.forEach(entry => {
                const li = document.createElement('li');
                li.textContent = `${entry.name}: ${entry.score}`;
                leaderboardList.appendChild(li);
            });
        }

        function update() {
            if (gameOver) return;

            // Move the snake's head forward first
            let newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y, color: snake[0].color };

            // Check for collision (wall or self)
            if (
                newHead.x < 0 ||
                newHead.x >= tileCount ||
                newHead.y < 0 ||
                newHead.y >= tileCount ||
                snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)
            ) {
                gameOver = true;
                return;
            }

            prevSnake = snake.map(seg => ({ ...seg }));
            snake.unshift(newHead); // Add new head

            // Check if food is eaten
            if (newHead.x === food.x && newHead.y === food.y) {
                // Change head color to food color
                snake[0].color = food.color;

                // Generate new food
                food = generateFood();
                score++;
                scoreDisplay.textContent = `Score: ${score}`;

                // Activate the floating text from the snake's head position
                floatingText = {
                    startX: newHead.x * gridSize + gridSize / 2,
                    startY: newHead.y * gridSize + gridSize / 2,
                    targetY: newHead.y * gridSize - gridSize * 2,
                    x: newHead.x * gridSize + gridSize / 2,
                    y: newHead.y * gridSize + gridSize / 2,
                    opacity: 1.0,
                    progress: 0.0,
                };

                // Remove the floating text after 3 seconds (fallback)
                if (floatingTextTimer) clearTimeout(floatingTextTimer);
                floatingTextTimer = setTimeout(() => {
                    floatingText = null;
                }, 3000);

                if (score % 10 === 0) {
                    interval = Math.max(50, interval - 8);
                    speed++;
                    speedDisplay.textContent = `Speed: ${speed}`;
                }
                // Do not remove tail (snake grows)
            } else {
                // Remove the tail if no food is eaten
                snake.pop();
            }

            animProgress = 0;
            updateFloatingText(); // Update floating text position and opacity
        }


        function frameLoop(timestamp) {
            if (lastFrameTime === null) lastFrameTime = timestamp;
            let dt = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            let moveTime = interval;
            if (gameOver || countdown > 0) {
                draw();
                return;
            }
            animProgress += dt / moveTime;
            if (animProgress >= 1) {
                animProgress = 1;
                update();
            }
            draw();
            if (!gameOver) requestAnimationFrame(frameLoop);
        }

        startButton.addEventListener('click', () => {
            startGame();
            updateLeaderboardUI();
        });
        restartButton.addEventListener('click', startGame); // Add event listener to restart button

        window.addEventListener('keydown', e => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y === 0) direction = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y === 0) direction = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x === 0) direction = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x === 0) direction = { x: 1, y: 0 };
                    break;
            }
        });

        // Touch/click controls for mobile and desktop
        snakeControlsButtonUp.addEventListener('touchstart', e => { e.preventDefault(); if (direction.y === 0) direction = { x: 0, y: -1 }; });
        snakeControlsButtonDown.addEventListener('touchstart', e => { e.preventDefault(); if (direction.y === 0) direction = { x: 0, y: 1 }; });
        snakeControlsButtonLeft.addEventListener('touchstart', e => { e.preventDefault(); if (direction.x === 0) direction = { x: -1, y: 0 }; });
        snakeControlsButtonRight.addEventListener('touchstart', e => { e.preventDefault(); if (direction.x === 0) direction = { x: 1, y: 0 }; });

        snakeControlsButtonUp.addEventListener('click', () => { if (direction.y === 0) direction = { x: 0, y: -1 }; });
        snakeControlsButtonDown.addEventListener('click', () => { if (direction.y === 0) direction = { x: 0, y: 1 }; });
        snakeControlsButtonLeft.addEventListener('click', () => { if (direction.x === 0) direction = { x: -1, y: 0 }; });
        snakeControlsButtonRight.addEventListener('click', () => { if (direction.x === 0) direction = { x: 1, y: 0 }; });

        async function subscribeToLeaderboard() {

            const changes = _supabase
            .channel('table-db-changes')
            .on(
                'postgres_changes',
                {
                event: 'INSERT',
                schema: 'public',
                table: 'leaderboard',
                },
                (payload) => updateLeaderboardUI()
            )
            .subscribe()
        }
        subscribeToLeaderboard(); // Initial fetch of leaderboard

        const authModal = document.getElementById('authModal');
        const authForm = document.getElementById('authForm');
        let emailInput = document.getElementById('email');
        //const toggleAuthMode = document.getElementById('toggleAuthMode');
        const authModalTitle = document.getElementById('authModalTitle');

        let isSignUpMode = false; // Tracks whether the modal is in sign-up or login mode

        async function checkAuth() {
            const { data: { user } } = await _supabase.auth.getUser();
            if (!user) {
                // Show the modal if the user is not signed in
                authModal.style.display = 'block';
                if (startButton) startButton.style.display = 'none';
            } else {
                console.log('User is signed in:', user);

                const userid = user.id;

                const { data, error } = await _supabase
                .from('userdata')
                .select('name');

                if (error) {
                    alert('Error fetching user data: ' + error.message);
                }
                else{
                    console.log('User data:', data);
                    if (data.length > 0) {
                        const userData = data[0];
                        // You can display the user's name or any other data as needed
                        if (userData.name) {
                            console.log('User name:', userData.name);
                            userName = userData.name; // Store the user's name
                            authModal.style.display = 'none'; // Hide the modal
                            if (startButton) startButton.style.display = 'block'; // Allow the user to start the game
                        } else {
                            console.log('No name found for this user.');
                            // Optionally, you can prompt the user to enter their name
                            authModal.style.display = 'block'; // Show the modal to enter name
                            authModalTitle.textContent = 'Enter Your Name';
                            authForm.innerHTML = `
                                <input type="text" id="name" placeholder="Name" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                                <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
                            `;
                            authForm.addEventListener('submit', async (e) => {
                                e.preventDefault();
                                const name = document.getElementById('name').value;
                                if (!name) {
                                    alert('Please enter your name.');
                                    return;
                                }

                                const { data, error } = await _supabase
                                .from('userdata')
                                .insert({ memid: userid, name: name})
                                .select()

                                if (error) {
                                    console.error('Error updating user data:', error.message);
                                    alert('Error: ' + error.message);
                                } else {
                                    console.log('User data updated successfully:', name);
                                    authModal.style.display = 'none'; // Hide the modal after successful update
                                    checkAuth(); // Recheck authentication
                                }
                            });
                        }
                        if (startButton) startButton.style.display = 'block'; // Allow the user to start the game
                        if (restartButton) restartButton.style.display = 'block'; // Allow the user to restart the game
                        updateLeaderboardUI(); // Update the leaderboard UI     
                    } 
                    else {
                        console.log('No user data found for this user.');
                        authModal.style.display = 'block'; // Show the modal to enter name
                        authModalTitle.textContent = 'Enter Your Name';
                        authForm.innerHTML = `
                            <input type="text" id="name" placeholder="Name" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                            <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
                        `;
                        authForm.addEventListener('submit', async (e) => {
                            e.preventDefault();
                            const name = document.getElementById('name').value;
                            if (!name) {
                                alert('Please enter your name.');
                                return;
                            }

                            const { data, error } = await _supabase
                            .from('userdata')
                            .insert({ memid: userid, name: name})
                            .select()

                            if (error) {
                                console.error('Error updating user data:', error.message);
                                alert('Error: ' + error.message);
                            } else {
                                console.log('User data updated successfully:', name);
                                authModal.style.display = 'none'; // Hide the modal after successful update
                                checkAuth(); // Recheck authentication
                            }
                        });
                    }
                }
            }
        }

        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            emailInput = document.getElementById('email');
            const email = emailInput.value;

            if (isSignUpMode) {
                // Sign-up logic
                console.log('Submitting magic link for email:', email);
                const { data, error } = await _supabase.auth.signInWithOtp({
                    email: email,
                    options: {
                        // set this to false if you do not want the user to be automatically signed up
                        //shouldCreateUser: false,
                        emailRedirectTo: 'https://mapkind.github.io/rigrecovery',
                    },
                })
                if(!error){
                    console.log('User signed up:', data);
                    alert('Sign-up successful! Please check your email for the magic link.');
                    // Hide the modal after successful sign-up
                    authModal.style.display = 'none'; // Hide the modal after successful sign-up
                    checkAuth(); // Recheck authentication
                }
                else{
                    console.error('Error signing up:', error.message);
                    alert('Error: ' + error.message);
                    return;
                }
            } 
            else {
                console.log('Submitting magic link for email:', email);
                // Magic link sign-in logic
                const { error } = await _supabase.auth.signInWithOtp({
                    email: email,
                    options: {
                        //data: { name },
                        // set this to false if you do not want the user to be automatically signed up
                        //shouldCreateUser: false,
                        emailRedirectTo: 'https://mapkind.github.io/rigrecovery',
                    },
                });

                if (error) {
                    console.error('Error sending magic link:', error.message);
                    alert('Error: ' + error.message);
                } else {
                    alert('Magic link sent! Check your email to log in.');
                }
            }
        });

        /*toggleAuthMode.addEventListener('click', (e) => {
            e.preventDefault();
            isSignUpMode = !isSignUpMode;
            toggleAuthMode.textContent = isSignUpMode ? 'Already a user? Log in here.' : 'Not a user? Sign up here.';
            authModalTitle.textContent = isSignUpMode ? 'Sign Up' : 'Log In';
            authForm.innerHTML = isSignUpMode
                ? `
                    <input type="email" id="email" placeholder="Email" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                    <button type="submit" style="padding: 10px 20px; font-size: 16px;">Sign Up</button>
                `
                : `
                    <input type="email" id="email" placeholder="Email" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                    <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
                `;
        });*/

        startButton.addEventListener('click', async () => {
            const { data: { user } } = await _supabase.auth.getUser();
            if (!user) {
                alert('You must be signed in to play the game.');
                authModal.style.display = 'block';
            } else {
                startGame();
            }
        });

        // Check authentication on page load
        checkAuth();

        let truckImage = null;

function preloadTruckImage() {
    const truckSVG = document.getElementById('truckSVG');
    const svgData = new XMLSerializer().serializeToString(truckSVG);
    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);

    truckImage = new Image();
    truckImage.src = url;

    truckImage.onload = () => {
        console.log('Truck image preloaded successfully.');
        URL.revokeObjectURL(url); // Release the URL object
    };
}

preloadTruckImage();
    </script>
</body>
</html>
