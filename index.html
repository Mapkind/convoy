<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rig Recovery</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.49.4/dist/umd/supabase.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
        }
        canvas {
            border: 1px solid #fff;
        }
        #scoreDisplay, #speedDisplay, #leaderboard {
            font-family: 'Press Start 2P', sans-serif;
        }
        #leaderboardList {
            padding-left: 50px; /* Optional for better alignment */
        }
        #leaderboardList li {
            margin-bottom: 10px; /* Add 10px space between items */
        }
        #authModal {
            display: none;
            position: fixed;
            width: 300px; /* Fixed width for the modal */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #authModal h3 {
            margin: 0 0 10px 0;
        }
        #authModal input {
            display: block;
            margin-bottom: 10px;
            width: 100%;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="scoreDisplay" style="position: absolute; color: white; font-size: 16px;">Score: 0</div>
    <div id="speedDisplay" style="position: absolute; color: white; font-size: 16px;">Speed: 1</div>
    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <div id="leaderboard" style="position: absolute; display: flex; flex-direction: column; justify-content: center; align-items: center; color: yellow; font-size: 14px; pointer-events: none; width: 400px; text-align: center; opacity: 0.5; z-index: 1;">
        <h3 style="text-align: center;">Leaderboard</h3>
        <ol id="leaderboardList" style="margin:0 auto; display: inline-block; text-align: left; padding-left: 1.5em;"></ol>
    </div>

    <button id="startButton" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; padding: 10px;">Start!</button>
    <button id="restartButton" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; padding: 10px;">Start!</button>

    <!-- Mobile-friendly arrow controls -->
    <div id="snakeControls" style="position: absolute; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; z-index: 10;">
        <div style="display: flex; justify-content: center;">
            <button id="snakeControlsButtonUp" aria-label="Up" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #eee;">▲</button>
        </div>
        <div style="display: flex; justify-content: center;">
            <button id="snakeControlsButtonLeft" aria-label="Left" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #eee;">◀</button>
            <div style="width: 60px; height: 60px; margin: 5px;"></div>
            <button id="snakeControlsButtonRight" aria-label="Right" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #eee;">▶</button>
        </div>
        <div style="display: flex; justify-content: center;">
            <button id="snakeControlsButtonDown" aria-label="Down" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #eee;">▼</button>
        </div>
    </div>

    <div id="authModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);">
        <h3 id="authModalTitle">Sign In/Sign Up</h3>
        <form id="authForm">
            <input type="email" id="email" placeholder="Email" required style="display: block; margin-bottom: 10px; width: 250px; padding: 10px;">
            <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
        </form>
        <!--<p style="margin-top: 10px; text-align: center;">
            <a href="#" id="toggleAuthMode" style="color: blue; text-decoration: underline;">Not a user? Sign up here.</a>
        </p>-->
    </div>

    <svg id="truckSVG" data-name="truckSVG" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" width="24" height="24" color="white" style="display: none;">
        <defs>
            <style>.cls-637b87aff95e86b59c57a1a5-1{fill:none;stroke:currentColor;stroke-miterlimit:10;}</style>
        </defs>
        <line class="cls-637b87aff95e86b59c57a1a5-1" x1="15.87" y1="17.8" x2="12" y2="17.8"></line>
        <polyline class="cls-637b87aff95e86b59c57a1a5-1" points="7.71 17.8 5.32 17.8 5.32 12.07 6.27 6.34 17.73 6.34 19.64 12.07 22.5 12.07 22.5 17.8 20.54 17.8"></polyline>
        <circle class="cls-637b87aff95e86b59c57a1a5-1" cx="18.2" cy="18.27" r="2.39"></circle>
        <circle class="cls-637b87aff95e86b59c57a1a5-1" cx="9.61" cy="18.27" r="2.39"></circle>
        <line class="cls-637b87aff95e86b59c57a1a5-1" x1="19.64" y1="12.07" x2="8.18" y2="12.07"></line>
        <line class="cls-637b87aff95e86b59c57a1a5-1" x1="12.95" y1="8.25" x2="12.95" y2="12.07"></line>
        <rect class="cls-637b87aff95e86b59c57a1a5-1" x="1.5" y="9.2" width="3.82" height="6.68" rx="1.91"></rect>
    </svg>

    <script>
        const { createClient } = supabase
        const _supabase = createClient('https://qplxbyiotkuvsvganuhn.supabase.co', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFwbHhieWlvdGt1dnN2Z2FudWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTEwNTkwMTUsImV4cCI6MjA2NjYzNTAxNX0.NM4YbUhQmlqw9ugOBEYQLgVSlg2gR3RE-sTQKRXGSvk')
        console.log('Supabase client created:', _supabase);
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const speedDisplay = document.getElementById('speedDisplay');
        const leaderboardList = document.getElementById('leaderboardList');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const snakeControlsButtonUp = document.getElementById('snakeControlsButtonUp');
        const snakeControls = document.getElementById('snakeControls');
        const snakeControlsButtonDown = document.getElementById('snakeControlsButtonDown');
        const snakeControlsButtonLeft = document.getElementById('snakeControlsButtonLeft');
        const snakeControlsButtonRight = document.getElementById('snakeControlsButtonRight');

        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

let userName;
let snake, direction, food, gameOver, score, speed, interval;
let countdown = 0;
let countdownInterval = null;
let animProgress = 1;
let lastFrameTime = null;
let prevSnake = null;

// For the pop effect on the larger head
let headPopActive = false;
let headPopTimer = null;

let leaderboard = []; // Array to store leaderboard entries

// Each truck is an object: { x, y, color }
function randomTruckColor() {
    // Pick a random color for the truck body
    const colors = ['#e53935', '#43a047', '#1e88e5', '#fbc02d', '#8e24aa', '#f57c00', '#00acc1', '#6d4c41'];
    return colors[Math.floor(Math.random() * colors.length)];
}

function resetGame() {
    // Start with a single truck (the head)
    snake = [
        { x: 10, y: 10, color: 'lime' } // The player's truck is always lime
    ];
    direction = { x: 1, y: 0 };
    food = generateFood();
    gameOver = false;
    score = 0;
    speed = 1;
    interval = 200;
    scoreDisplay.textContent = `Score: ${score}`;
    speedDisplay.textContent = `Speed: ${speed}`;
    restartButton.style.display = 'none';
    animProgress = 1;
    lastFrameTime = null;
    prevSnake = null;
    document.getElementById('leaderboard').style.opacity = 0.1;
}

function startGame() {
    resetGame();
    startButton.style.display = 'none';
    countdown = 3;
    draw();
    countdownInterval = setInterval(() => {
        countdown--;
        draw();
        if (countdown === 0) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            animProgress = 1;
            lastFrameTime = null;
            prevSnake = null;
            requestAnimationFrame(frameLoop);
        }
    }, 1000);
}



        function isMobile() {
            // Basic mobile detection
            return window.innerWidth <= 700 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function positionDisplays() {
            const gap = 10;
            const isMobileDevice = isMobile();
            // Center authModal over the game canvas on mobile
            const authModal = document.getElementById('authModal');
            const gameCanvas = document.getElementById('gameCanvas');
            if (isMobileDevice && authModal && gameCanvas) {
                console.log('Positioning auth modal for mobile');
                // Get canvas position and size
                const rect = gameCanvas.getBoundingClientRect();
                // Center modal over canvas
                authModal.style.position = 'absolute';
                authModal.style.left = (rect.left + rect.width / 2 + window.scrollX) + 'px';
                authModal.style.top = (rect.top + rect.height / 2 + window.scrollY) + 'px';
                authModal.style.transform = 'translate(-50%, -50%)';
                authModal.style.zIndex = '1000';
            } else if (authModal) {
                // Restore default (fixed, centered in viewport)
                authModal.style.position = 'fixed';
                authModal.style.left = '50%';
                authModal.style.top = '50%';
                authModal.style.transform = 'translate(-50%, -50%)';
                authModal.style.zIndex = '1000';
            }

            // Position start and restart buttons 20px above the bottom of the game canvas, centered horizontally, and ensure they are within the canvas
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            if (gameCanvas) {
                const rect = gameCanvas.getBoundingClientRect();
                // Calculate button width and height (fallback to 120x40 if not rendered yet)
                const buttonWidth = (startButton && startButton.offsetWidth) ? startButton.offsetWidth : 120;
                const buttonHeight = (startButton && startButton.offsetHeight) ? startButton.offsetHeight : 40;
                // Y position: 20px above the bottom, but not below the canvas
                const buttonY = rect.top + rect.height - 20 - buttonHeight + window.scrollY;
                // X position: center within the canvas
                const buttonX = rect.left + rect.width / 2 + window.scrollX;
                // Place start button
                if (startButton) {
                    startButton.style.position = 'absolute';
                    startButton.style.left = buttonX + 'px';
                    startButton.style.top = buttonY + 'px';
                    startButton.style.transform = 'translate(-50%, 0)';
                    startButton.style.zIndex = '1001';
                    // Ensure button is a child of the canvas's parent (so it overlays the canvas)
                    if (gameCanvas.parentNode && startButton.parentNode !== gameCanvas.parentNode) {
                        gameCanvas.parentNode.appendChild(startButton);
                    }
                }
                // Place restart button
                if (restartButton) {
                    restartButton.style.position = 'absolute';
                    restartButton.style.left = buttonX + 'px';
                    restartButton.style.top = buttonY + 'px';
                    restartButton.style.transform = 'translate(-50%, 0)';
                    restartButton.style.zIndex = '1001';
                    if (gameCanvas.parentNode && restartButton.parentNode !== gameCanvas.parentNode) {
                        gameCanvas.parentNode.appendChild(restartButton);
                    }
                }
            }
            const canvasRect = canvas.getBoundingClientRect();

            if (isMobileDevice) {
                console.log('Positioning displays for mobile');
                // Move all elements to the top of the page for mobile
                // Score: top right
                scoreDisplay.style.position = 'absolute';
                scoreDisplay.style.top = `${gap + window.scrollY}px`;
                scoreDisplay.style.left = `calc(100vw - ${scoreDisplay.offsetWidth + gap}px)`;

                // Speed: top left
                speedDisplay.style.position = 'absolute';
                speedDisplay.style.top = `${gap + window.scrollY}px`;
                speedDisplay.style.left = `${gap + window.scrollX}px`;

                // Move the game canvas to the top center of the page
                const gameCanvas = document.getElementById('gameCanvas');
                let canvasTop = gap + scoreDisplay.offsetHeight + gap + window.scrollY;
                if (gameCanvas) {
                    gameCanvas.style.position = 'absolute';
                    gameCanvas.style.top = `${canvasTop}px`;
                    gameCanvas.style.left = '50vw';
                    gameCanvas.style.transform = 'translateX(-50%)';
                }

                // Controls: just below the game canvas, centered
                if (snakeControls && gameCanvas) {
                    snakeControls.style.position = 'absolute';
                    snakeControls.style.top = `${canvasTop + gameCanvas.offsetHeight + gap}px`;
                    snakeControls.style.left = '50vw';
                    snakeControls.style.transform = 'translateX(-50%)';
                }

                // Leaderboard: centered inside the game canvas (overlay, under trucks)
                const leaderboard = document.getElementById('leaderboard');
                if (leaderboard && gameCanvas) {
                    // Insert leaderboard as a sibling after the canvas if not already
                    if (gameCanvas.nextSibling !== leaderboard) {
                        gameCanvas.parentNode.insertBefore(leaderboard, gameCanvas.nextSibling);
                    }
                    // Set leaderboard width and center both horizontally and vertically within the canvas
                    const leaderboardWidth = Math.max(220, Math.floor(gameCanvas.width * 0.7));
                    leaderboard.style.position = 'absolute';
                    leaderboard.style.width = leaderboardWidth + 'px';
                    leaderboard.style.left = (gameCanvas.getBoundingClientRect().left + (gameCanvas.width - leaderboardWidth) / 2 + window.scrollX) + 'px';
                    // Vertically center: use flexbox on the leaderboard for content, but absolutely center the leaderboard itself
                    leaderboard.style.visibility = 'hidden';
                    leaderboard.style.display = 'block';
                    // Force reflow
                    void leaderboard.offsetHeight;
                    const verticalCenter = gameCanvas.getBoundingClientRect().top + (gameCanvas.height - leaderboard.offsetHeight) / 2 + window.scrollY;
                    leaderboard.style.top = `${verticalCenter}px`;
                    leaderboard.style.visibility = 'visible';
                    leaderboard.style.height = '400px';
                    leaderboard.style.opacity = '0.1';
                    leaderboard.style.pointerEvents = 'none';
                    leaderboard.style.textAlign = 'center';
                    leaderboard.style.zIndex = '0';
                }
            } else {
                // Desktop: original centered overlay logic
                // Score: right above canvas, right-aligned
                scoreDisplay.style.position = 'absolute';
                scoreDisplay.style.top = `${canvasRect.top - 25 + window.scrollY}px`;
                scoreDisplay.style.left = `${canvasRect.right - scoreDisplay.offsetWidth + window.scrollX}px`;
                // Speed: left above canvas, left-aligned
                speedDisplay.style.position = 'absolute';
                speedDisplay.style.top = `${canvasRect.top - 25 + window.scrollY}px`;
                speedDisplay.style.left = `${canvasRect.left + window.scrollX}px`;

                // Controls: just below the canvas, centered
                if (snakeControls) {
                    snakeControls.style.position = 'absolute';
                    snakeControls.style.top = `${canvasRect.bottom + 20 + window.scrollY}px`;
                    snakeControls.style.left = `${canvasRect.left + canvasRect.width / 2 + window.scrollX}px`;
                    snakeControls.style.transform = 'translateX(-50%)';
                }

                // Move leaderboard inside the canvas (centered overlay, under trucks)
                const leaderboard = document.getElementById('leaderboard');
                const gameCanvas = document.getElementById('gameCanvas');
                if (leaderboard && gameCanvas && gameCanvas.parentNode) {
                    // Insert leaderboard as a sibling after the canvas if not already
                    if (gameCanvas.nextSibling !== leaderboard) {
                        gameCanvas.parentNode.insertBefore(leaderboard, gameCanvas.nextSibling);
                    }
                    // Set leaderboard width and center both horizontally and vertically within the canvas
                    const leaderboardWidth = Math.max(220, Math.floor(canvas.width * 0.7));
                    leaderboard.style.position = 'absolute';
                    leaderboard.style.width = leaderboardWidth + 'px';
                    leaderboard.style.height = '400px';
                    leaderboard.style.left = (canvasRect.left + (canvas.width - leaderboardWidth) / 2 + window.scrollX) + 'px';

                    // Vertically center: use flexbox on the leaderboard for content, but absolutely center the leaderboard itself
                    leaderboard.style.visibility = 'hidden';
                    leaderboard.style.display = 'block';
                    // Force reflow
                    void leaderboard.offsetHeight;
                    const verticalCenter = canvasRect.top + (canvasRect.height - leaderboard.offsetHeight) / 2 + window.scrollY;
                    leaderboard.style.top = `${verticalCenter}px`;
                    leaderboard.style.visibility = 'visible';

                    leaderboard.style.opacity = '0.1';
                    leaderboard.style.pointerEvents = 'none';
                    leaderboard.style.textAlign = 'center';
                    leaderboard.style.zIndex = '0';
                }
            }
        }
        

        window.addEventListener('resize', positionDisplays); // Reposition on window resize
        window.addEventListener('scroll', positionDisplays); // Reposition on scroll (for mobile)

        // Ensure all elements are rendered and styled before initial positioning
        window.addEventListener('DOMContentLoaded', () => {
            // Use a longer timeout and multiple calls to ensure layout is correct on mobile
            setTimeout(positionDisplays, 100);
            setTimeout(positionDisplays, 300);
            setTimeout(positionDisplays, 600);
            // Also call after all resources (images/fonts) are loaded
            window.addEventListener('load', () => {
                setTimeout(positionDisplays, 100);
                setTimeout(positionDisplays, 300);
                setTimeout(positionDisplays, 600);
            });
        });

function generateFood() {
    let newFood;
    do {
        newFood = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount), color: randomTruckColor() };
    } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
    return newFood;
}


        let floatingText = null; // Store the floating text object
let floatingTextTimer = null; // Timer to remove the floating text

function drawFloatingText() {
    if (!floatingText) return;

    const { x, y, opacity } = floatingText;

    ctx.save();
    ctx.globalAlpha = opacity; // Set transparency

    // Draw white outline
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 5;
    ctx.font = '20px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.strokeText('+1', x, y);

    // Draw purple fill
    ctx.fillStyle = 'purple';
    ctx.fillText('+1', x, y);

    ctx.restore();
}

function updateFloatingText() {
    if (!floatingText) return;

    // Smoothly move the text upward using interpolation
    floatingText.progress += 0.1; // Increment progress (adjust speed as needed)

    // Interpolate position based on progress
    floatingText.y = floatingText.startY + (floatingText.targetY - floatingText.startY) * floatingText.progress;

    // Fade out the text based on progress
    floatingText.opacity = 1.0 - floatingText.progress;

    // Remove the floating text when it reaches the target or becomes invisible
    if (floatingText.progress >= 1.0) {
        floatingText = null;
        clearTimeout(floatingTextTimer);
    }
}

// Draw a truck using a pixel-art style inspired by truck.png
function drawTruck(x, y, color, angle = 0, mirror = false) {
    if (!truckImage) {
        console.error('Truck image not loaded yet.');
        return;
    }

    const px = x * gridSize;
    const py = y * gridSize;

    ctx.save();
    ctx.translate(px + gridSize / 2, py + gridSize / 2);
    if (mirror) {
        ctx.scale(-1, 1); // Mirror horizontally
    }
    ctx.rotate(angle);
    ctx.translate(-gridSize / 2, -gridSize / 2);

    // Draw the preloaded truck image on the canvas
    ctx.drawImage(truckImage, 0, 0, gridSize, gridSize);

    // Apply the truck's assigned color as a tint
    ctx.globalCompositeOperation = 'multiply'; // Use 'multiply' to blend the color with the image
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, gridSize, gridSize);

    ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
    ctx.restore();
}

// Helper to get angle and mirror for truck based on direction
function getTruckDrawParams(dir, prevDir = null) {
    // Returns { angle, mirror }
    // Truck SVG points right by default
    if (dir.x === 1 && dir.y === 0) return { angle: 0, mirror: false }; // right
    if (dir.x === 0 && dir.y === -1) return { angle: -Math.PI / 2, mirror: false }; // up
    if (dir.x === 0 && dir.y === 1) return { angle: Math.PI / 2, mirror: false }; // down
    if (dir.x === -1 && dir.y === 0) {
        // If coming from up or down, mirror horizontally instead of rotating 180deg
        if (prevDir && (prevDir.y === -1 || prevDir.y === 1)) {
            return { angle: 0, mirror: true };
        }
        return { angle: Math.PI, mirror: false };
    }
    return { angle: 0, mirror: false };
}

        function draw() {
            // Draw background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw countdown if active
            if (countdown > 0) {
                ctx.fillStyle = 'purple';
                ctx.font = `${Math.floor(canvas.width * 0.8)}px 'Press Start 2P', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = 0.85;
                ctx.fillText(countdown, canvas.width / 2, canvas.height / 2);
                ctx.globalAlpha = 1.0;
                return;
            }

            if (gameOver) {
                document.getElementById('leaderboard').style.opacity = 1; // Hide leaderboard on game over
                ctx.fillStyle = 'red';
                ctx.font = '20px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height - 80); // Position at the bottom of the canvas

                // Submit the score automatically if game is over
                submitScore(score);

                restartButton.style.display = 'block'; // Show the restart button
                return;
            }


            // Draw all trucks in the snake (head + collected trucks)
            for (let i = 0; i < snake.length; i++) {
                let seg = snake[i];
                let prevSeg = prevSnake && prevSnake[i] ? prevSnake[i] : seg;
                // Interpolate position for smooth movement
                let x = (prevSeg.x + (seg.x - prevSeg.x) * animProgress);
                let y = (prevSeg.y + (seg.y - prevSeg.y) * animProgress);
                // For the head, use the current direction for angle/mirror
                if (i === 0) {
                    const { angle, mirror } = getTruckDrawParams(direction, snake[1] ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y } : null);
                    drawTruck(x, y, seg.color, angle, mirror);
                } else {
                    // For body, infer direction from previous segment, and also pass previous direction for left-turn mirroring
                    let angle = 0, mirror = false;
                    if (i > 0) {
                        let prev = snake[i - 1];
                        let dx = seg.x - prev.x;
                        let dy = seg.y - prev.y;
                        // For mirroring, also need the direction before this segment
                        let prevDir = null;
                        if (i > 1) {
                            let prev2 = snake[i - 2];
                            prevDir = { x: prev.x - prev2.x, y: prev.y - prev2.y };
                        }
                        ({ angle, mirror } = getTruckDrawParams({ x: dx, y: dy }, prevDir));
                    }
                    drawTruck(x, y, seg.color, angle, mirror);
                }
            }

            // Draw the food as a random colored truck (always facing right)
            drawTruck(food.x, food.y, food.color, 0, false);

            // Draw floating text
            drawFloatingText();
        }

        async function fetchLeaderboard() {
            const { data, error } = await _supabase
                .from('leaderboard')
                .select('name, score')
                .order('score', { ascending: false })
                .limit(10);

            if (error) {
                console.error('Error fetching leaderboard:', error);
                return [];
            }

            return data;
        }

        async function submitScore(score) {
            const { data: { user } } = await _supabase.auth.getUser();
            if (!user) {
                console.error('Error fetching user:', error);
                return;
            }
            //console.log("user.user_metadata: ", user);
            //const name = "TEST"; // Default name for testing purposes
            //const name = user.user_metadata.name; // Get the user's name from metadata
            const { error: insertError } = await _supabase
                .from('leaderboard')
                .insert({ score: score, name: userName, memid: user.id })
                .select();

            if (insertError) {
                console.error('Error submitting score:', insertError);
            } else {
                updateLeaderboardUI(); // Refresh leaderboard after submission
            }
        }

        async function updateLeaderboardUI() {
            const leaderboard = await fetchLeaderboard();
            leaderboardList.innerHTML = ''; // Clear existing leaderboard
            leaderboard.forEach(entry => {
                const li = document.createElement('li');
                li.textContent = `${entry.name}: ${entry.score}`;
                leaderboardList.appendChild(li);
            });
        }

        function update() {
            if (gameOver) return;

            let head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y, color: snake[0].color };

            if (head.x === food.x && head.y === food.y) {

                head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y, color: food.color };
                
                if (
                    head.x < 0 || 
                    head.x >= tileCount || 
                    head.y < 0 || 
                    head.y >= tileCount || 
                    snake.some(segment => segment.x === head.x && segment.y === head.y)
                ) {
                    gameOver = true;
                    return;
                }

            prevSnake = snake.map(seg => ({ ...seg }));
            snake.unshift(head); // Add new head
                //console.log("Truck saved! ", food);
                // Ensure the food truck is added only once
                if (!snake.some(segment => segment.x === food.x && segment.y === food.y)) {
                    
                    snake.push({ x: food.x, y: food.y, color: food.color });
                    
                }
                //console.log("Snake array after eating food:", snake);
                food = generateFood(); // Generate new food
                score++;
                scoreDisplay.textContent = `Score: ${score}`;

                // Activate the floating text from the snake's head position
                floatingText = {
                    startX: head.x * gridSize + gridSize / 2, // Starting position (snake's head)
                    startY: head.y * gridSize + gridSize / 2,
                    targetY: head.y * gridSize - gridSize * 2, // Move upward by 2 grid units
                    x: head.x * gridSize + gridSize / 2, // X position remains constant
                    y: head.y * gridSize + gridSize / 2, // Current position
                    opacity: 1.0, // Fully visible
                    progress: 0.0, // Start progress at 0
                };

                // Remove the floating text after 3 seconds (fallback)
                if (floatingTextTimer) clearTimeout(floatingTextTimer);
                floatingTextTimer = setTimeout(() => {
                    floatingText = null;
                }, 3000);

                if (score % 10 === 0) {
                    interval = Math.max(50, interval - 8);
                    speed++;
                    speedDisplay.textContent = `Speed: ${speed}`;
                }
            } 
            else {
                head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y, color: snake[0].color };
                if (
                    head.x < 0 || 
                    head.x >= tileCount || 
                    head.y < 0 || 
                    head.y >= tileCount || 
                    snake.some(segment => segment.x === head.x && segment.y === head.y)
                ) {
                    gameOver = true;
                    return;
                }

            prevSnake = snake.map(seg => ({ ...seg }));
            snake.unshift(head); // Add new head
                //snake.unshift(head); // Add new head
                snake.pop(); // Remove the tail if no food is eaten
            }

            animProgress = 0;
            updateFloatingText(); // Update floating text position and opacity
        }


        function frameLoop(timestamp) {
            if (lastFrameTime === null) lastFrameTime = timestamp;
            let dt = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            let moveTime = interval;
            if (gameOver || countdown > 0) {
                draw();
                return;
            }
            animProgress += dt / moveTime;
            if (animProgress >= 1) {
                animProgress = 1;
                update();
            }
            draw();
            if (!gameOver) requestAnimationFrame(frameLoop);
        }

        startButton.addEventListener('click', () => {
            startGame();
            updateLeaderboardUI();
        });
        restartButton.addEventListener('click', startGame); // Add event listener to restart button

        window.addEventListener('keydown', e => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y === 0) direction = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y === 0) direction = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x === 0) direction = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x === 0) direction = { x: 1, y: 0 };
                    break;
            }
        });

        // Touch/click controls for mobile and desktop
        snakeControlsButtonUp.addEventListener('touchstart', e => { e.preventDefault(); if (direction.y === 0) direction = { x: 0, y: -1 }; });
        snakeControlsButtonDown.addEventListener('touchstart', e => { e.preventDefault(); if (direction.y === 0) direction = { x: 0, y: 1 }; });
        snakeControlsButtonLeft.addEventListener('touchstart', e => { e.preventDefault(); if (direction.x === 0) direction = { x: -1, y: 0 }; });
        snakeControlsButtonRight.addEventListener('touchstart', e => { e.preventDefault(); if (direction.x === 0) direction = { x: 1, y: 0 }; });

        snakeControlsButtonUp.addEventListener('click', () => { if (direction.y === 0) direction = { x: 0, y: -1 }; });
        snakeControlsButtonDown.addEventListener('click', () => { if (direction.y === 0) direction = { x: 0, y: 1 }; });
        snakeControlsButtonLeft.addEventListener('click', () => { if (direction.x === 0) direction = { x: -1, y: 0 }; });
        snakeControlsButtonRight.addEventListener('click', () => { if (direction.x === 0) direction = { x: 1, y: 0 }; });

        async function subscribeToLeaderboard() {

            const changes = _supabase
            .channel('table-db-changes')
            .on(
                'postgres_changes',
                {
                event: 'INSERT',
                schema: 'public',
                table: 'leaderboard',
                },
                (payload) => updateLeaderboardUI()
            )
            .subscribe()
        }
        subscribeToLeaderboard(); // Initial fetch of leaderboard

        const authModal = document.getElementById('authModal');
        const authForm = document.getElementById('authForm');
        let emailInput = document.getElementById('email');
        //const toggleAuthMode = document.getElementById('toggleAuthMode');
        const authModalTitle = document.getElementById('authModalTitle');

        let isSignUpMode = false; // Tracks whether the modal is in sign-up or login mode

        async function checkAuth() {
            const { data: { user } } = await _supabase.auth.getUser();
            if (!user) {
                // Show the modal if the user is not signed in
                authModal.style.display = 'block';
                if (startButton) startButton.style.display = 'none';
            } else {
                console.log('User is signed in:', user);

                const userid = user.id;

                const { data, error } = await _supabase
                .from('userdata')
                .select('name');

                if (error) {
                    alert('Error fetching user data: ' + error.message);
                }
                else{
                    console.log('User data:', data);
                    if (data.length > 0) {
                        const userData = data[0];
                        // You can display the user's name or any other data as needed
                        if (userData.name) {
                            console.log('User name:', userData.name);
                            userName = userData.name; // Store the user's name
                            authModal.style.display = 'none'; // Hide the modal
                            if (startButton) startButton.style.display = 'block'; // Allow the user to start the game
                        } else {
                            console.log('No name found for this user.');
                            // Optionally, you can prompt the user to enter their name
                            authModal.style.display = 'block'; // Show the modal to enter name
                            authModalTitle.textContent = 'Enter Your Name';
                            authForm.innerHTML = `
                                <input type="text" id="name" placeholder="Name" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                                <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
                            `;
                            authForm.addEventListener('submit', async (e) => {
                                e.preventDefault();
                                const name = document.getElementById('name').value;
                                if (!name) {
                                    alert('Please enter your name.');
                                    return;
                                }

                                const { data, error } = await _supabase
                                .from('userdata')
                                .insert({ memid: userid, name: name})
                                .select()

                                if (error) {
                                    console.error('Error updating user data:', error.message);
                                    alert('Error: ' + error.message);
                                } else {
                                    console.log('User data updated successfully:', name);
                                    authModal.style.display = 'none'; // Hide the modal after successful update
                                    checkAuth(); // Recheck authentication
                                }
                            });
                        }
                        if (startButton) startButton.style.display = 'block'; // Allow the user to start the game
                        if (restartButton) restartButton.style.display = 'block'; // Allow the user to restart the game
                        updateLeaderboardUI(); // Update the leaderboard UI     
                    } 
                    else {
                        console.log('No user data found for this user.');
                        authModal.style.display = 'block'; // Show the modal to enter name
                        authModalTitle.textContent = 'Enter Your Name';
                        authForm.innerHTML = `
                            <input type="text" id="name" placeholder="Name" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                            <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
                        `;
                        authForm.addEventListener('submit', async (e) => {
                            e.preventDefault();
                            const name = document.getElementById('name').value;
                            if (!name) {
                                alert('Please enter your name.');
                                return;
                            }

                            const { data, error } = await _supabase
                            .from('userdata')
                            .insert({ memid: userid, name: name})
                            .select()

                            if (error) {
                                console.error('Error updating user data:', error.message);
                                alert('Error: ' + error.message);
                            } else {
                                console.log('User data updated successfully:', name);
                                authModal.style.display = 'none'; // Hide the modal after successful update
                                checkAuth(); // Recheck authentication
                            }
                        });
                    }
                }
            }
        }

        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            emailInput = document.getElementById('email');
            const email = emailInput.value;

            if (isSignUpMode) {
                // Sign-up logic
                console.log('Submitting magic link for email:', email);
                const { data, error } = await _supabase.auth.signInWithOtp({
                    email: email,
                    options: {
                        // set this to false if you do not want the user to be automatically signed up
                        //shouldCreateUser: false,
                        emailRedirectTo: 'https://mapkind.github.io/rigrecovery',
                    },
                })
                if(!error){
                    console.log('User signed up:', data);
                    alert('Sign-up successful! Please check your email for the magic link.');
                    // Hide the modal after successful sign-up
                    authModal.style.display = 'none'; // Hide the modal after successful sign-up
                    checkAuth(); // Recheck authentication
                }
                else{
                    console.error('Error signing up:', error.message);
                    alert('Error: ' + error.message);
                    return;
                }
            } 
            else {
                console.log('Submitting magic link for email:', email);
                // Magic link sign-in logic
                const { error } = await _supabase.auth.signInWithOtp({
                    email: email,
                    options: {
                        //data: { name },
                        // set this to false if you do not want the user to be automatically signed up
                        //shouldCreateUser: false,
                        emailRedirectTo: 'https://mapkind.github.io/rigrecovery',
                    },
                });

                if (error) {
                    console.error('Error sending magic link:', error.message);
                    alert('Error: ' + error.message);
                } else {
                    alert('Magic link sent! Check your email to log in.');
                }
            }
        });

        /*toggleAuthMode.addEventListener('click', (e) => {
            e.preventDefault();
            isSignUpMode = !isSignUpMode;
            toggleAuthMode.textContent = isSignUpMode ? 'Already a user? Log in here.' : 'Not a user? Sign up here.';
            authModalTitle.textContent = isSignUpMode ? 'Sign Up' : 'Log In';
            authForm.innerHTML = isSignUpMode
                ? `
                    <input type="email" id="email" placeholder="Email" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                    <button type="submit" style="padding: 10px 20px; font-size: 16px;">Sign Up</button>
                `
                : `
                    <input type="email" id="email" placeholder="Email" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                    <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
                `;
        });*/

        startButton.addEventListener('click', async () => {
            const { data: { user } } = await _supabase.auth.getUser();
            if (!user) {
                alert('You must be signed in to play the game.');
                authModal.style.display = 'block';
            } else {
                startGame();
            }
        });

        // Check authentication on page load
        checkAuth();

        let truckImage = null;

function preloadTruckImage() {
    const truckSVG = document.getElementById('truckSVG');
    const svgData = new XMLSerializer().serializeToString(truckSVG);
    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);

    truckImage = new Image();
    truckImage.src = url;

    truckImage.onload = () => {
        console.log('Truck image preloaded successfully.');
        URL.revokeObjectURL(url); // Release the URL object
    };
}

preloadTruckImage();
    </script>
</body>
</html>
