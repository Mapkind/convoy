<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="shortcut icon" type="image/png" href="favicon.png?">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convoy</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.49.4/dist/umd/supabase.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            /* Organic, dense topographic SVG background */
            background-color: #1c1f1c;
            /*background-image: url('data:image/svg+xml;utf8,<svg width="600" height="600" viewBox="0 0 600 600" fill="none" xmlns="http://www.w3.org/2000/svg"><g stroke="%23444" stroke-width="1.1" fill="none"><path d="M120 180c30-40 80-60 120-40s80 80 120 100 100 0 120-40"/><path d="M100 200c40-60 100-80 160-40s100 100 160 120 120-20 140-60"/><path d="M80 220c50-80 120-100 200-40s120 120 200 140 140-40 160-80"/><path d="M60 240c60-100 140-120 240-40s140 140 240 160 160-60 180-100"/><path d="M200 100c-20 40-10 80 40 120s100 40 140 0 40-100 0-140-100-40-140 0z"/><path d="M300 200c-30 30-20 60 20 100s80 30 110-10 30-80-10-110-80-30-110 10z"/><path d="M400 300c-40 20-30 50 10 90s70 20 90-20 20-70-20-90-70-20-90 20z"/><path d="M500 400c-50 10-40 40 0 80s60 10 80-30 10-60-30-80-60-10-80 30z"/><path d="M150 350c-30-10-40-40-10-80s60-30 80 10 10 60-30 80-60 10-80-30z"/><path d="M250 450c-20-20-30-50 10-90s70-20 90 20 20 70-20 90-70 20-90-20z"/></g><g stroke="%23333" stroke-width="0.7" fill="none"><path d="M140 200c30-30 70-50 110-30s70 70 110 90 90 0 110-30"/><path d="M120 220c40-50 90-70 140-30s90 90 140 110 110-10 130-50"/><path d="M100 240c50-70 110-90 180-30s110 110 180 130 130-30 150-70"/><path d="M80 260c60-90 130-110 220-30s130 130 220 150 150-50 170-90"/><path d="M220 120c-20 30-10 60 30 100s80 30 110 0 30-80 0-110-80-30-110 0z"/><path d="M320 220c-30 20-20 50 20 80s70 20 90-10 20-70-10-90-70-20-90 10z"/><path d="M420 320c-40 10-30 40 10 70s60 10 70-20 10-60-20-70-60-10-70 20z"/><path d="M520 420c-50 0-40 30 0 60s50 0 60-30 0-50-30-60-50 0-60 30z"/><path d="M170 370c-30-10-40-30-10-60s50-20 60 10 0 50-30 60-50 0-60-30z"/><path d="M270 470c-20-10-30-40 10-70s60-10 70 20 10 60-20 70-60 10-70-20z"/></g></svg>');
            */

            background-image: url('https://cdn.prod.website-files.com/62bf6acab61c547c9bca665f/6863d7c20998705f29e52693_Contour-Map.svg');
            background-size: 2560px 1600px;
        }
        /*canvas {
            border: 4px solid #000000;
        }*/
        #scoreDisplay, #speedDisplay, #leaderboard {
            font-family: 'Press Start 2P', sans-serif;
        }
        #scoreDisplay, #speedDisplay, #gameOverMessage {
            text-shadow: 2px 2px 2px black;
        }
        #leaderboard{
            box-shadow: 0px 0px 0px 8px #121412; /* Pseudo outline */
            border: #1c1f1c 1px solid; /* Add a border to the leaderboard */
            border-radius: 5px; /* Add rounded corners */
        }
        #leaderboardList {
            padding-left: 50px; /* Optional for better alignment */
        }
        #leaderboardList li {
            margin-bottom: 10px; /* Add 10px space between items */
        }
        #authModal {
            display: none;
            position: fixed;
            width: 300px; /* Fixed width for the modal */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #f2ede2;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        #authModal h3 {
            margin: 0 0 10px 0;
        }
        #authModal input {
            display: block;
            margin-bottom: 10px;
            width: 100%;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="gameTitle" style="position: absolute; top: 80px; color: #d79811; font-family: 'Press Start 2P', sans-serif; font-size: 32px; text-align: center;">CONVOY</div>
    <div id="gameOverMessage" style="width: 400px; height: 400px; position: absolute; color: #d15252; text-align: center; font-size: 26px; padding-top: 600px; font-family: 'Press Start 2P', sans-serif; display: none;">GAME OVER</div>
    <div id="scoreDisplay" style="position: absolute; color: #f2ede2; font-size: 14px;">Score: 0</div>
    <div id="speedDisplay" style="position: absolute; color: #f2ede2; font-size: 14px;">Speed: 1</div>
    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <div id="leaderboard" style="position: absolute; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #1c1f1c; font-size: 14px; pointer-events: none; width: 400px; text-align: center; opacity: 1; z-index: 0;">
        <h3 id="leaderboardTitle" style="text-align: center;">Leaderboard</h3>
        <ol id="leaderboardList" style="margin:0 auto; display: inline-block; text-align: left; padding-left: 1.5em;"></ol>
    </div>

    <button id="startButton" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; padding: 10px; color: #f2ede2; background-color: #1c1f1c; font-family: 'Press Start 2P', sans-serif; font-size: small;">Start!</button>
    <button id="restartButton" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; padding: 10px; color: #f2ede2; background-color: #1c1f1c; font-family: 'Press Start 2P', sans-serif; font-size: small;">Start!</button>

    <!-- Mobile-friendly arrow controls (only visible on mobile) -->
    <div id="snakeControls" style="position: absolute; left: 50%; transform: translateX(-50%); display: none; flex-direction: column; align-items: center; z-index: 10;">
        <div style="display: flex; justify-content: center;">
            <button id="snakeControlsButtonUp" aria-label="Up" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #f2ede2;">▲</button>
        </div>
        <div style="display: flex; justify-content: center;">
            <button id="snakeControlsButtonLeft" aria-label="Left" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #f2ede2;">◀</button>
            <div style="width: 60px; height: 60px; margin: 5px;"></div>
            <button id="snakeControlsButtonRight" aria-label="Right" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #f2ede2;">▶</button>
        </div>
        <div style="display: flex; justify-content: center;">
            <button id="snakeControlsButtonDown" aria-label="Down" style="width: 60px; height: 60px; margin: 5px; font-size: 2em; border-radius: 50%; border: 2px solid #888; background: #f2ede2;">▼</button>
        </div>
    </div>

    <!-- Desktop movement instructions (only visible on desktop, below game canvas) -->
    <div id="desktopInstructions" style="display: none; width: 400px; position: absolute; left: 50%; transform: translateX(-50%); color: #1c1f1c; background: #f2ede2; padding: 8px 0px; text-align: center; border-radius: 8px; font-family: 'Press Start 2P', sans-serif; font-size: 12px; z-index: 10; opacity: 0.7; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
        Use <b>WASD</b> or <b>Arrow keys</b> to steer.
    </div>

    <div id="authModal" style="display: none; color: #f2ede2; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1c1f1c; padding: 20px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);">
        <h3 id="authModalTitle" style="color: #f2ede2; font-family: 'Press Start 2P', sans-serif; font-size: small;">Sign In/Sign Up</h3>
        <form id="authForm">
            <input type="email" id="email" placeholder="Email" required style="display: block; margin-bottom: 10px; width: 250px; padding: 10px; background-color: #f2ede2;">
            <button type="submit" style="padding: 10px 20px; font-size: 16px; color: #1c1f1c; font-family: 'Press Start 2P', sans-serif; font-size: small; background-color: #f2ede2;">Submit</button>
        </form>
        <!--<p style="margin-top: 10px; text-align: center;">
            <a href="#" id="toggleAuthMode" style="color: blue; text-decoration: underline;">Not a user? Sign up here.</a>
        </p>-->
    </div>

    <svg id="truckSVGold" data-name="truckSVGold" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-width="2" width="24" height="24" color="white" style="display: none;">
        <defs>
            <style>.cls-637b87aff95e86b59c57a1a5-1{fill:none;stroke:currentColor;stroke-miterlimit:10;}</style>
        </defs>
        <line class="cls-637b87aff95e86b59c57a1a5-1" x1="15.87" y1="17.8" x2="12" y2="17.8"></line>
        <polyline class="cls-637b87aff95e86b59c57a1a5-1" points="7.71 17.8 5.32 17.8 5.32 12.07 6.27 6.34 17.73 6.34 19.64 12.07 22.5 12.07 22.5 17.8 20.54 17.8"></polyline>
        <circle class="cls-637b87aff95e86b59c57a1a5-1" cx="18.2" cy="18.27" r="2.39"></circle>
        <circle class="cls-637b87aff95e86b59c57a1a5-1" cx="9.61" cy="18.27" r="2.39"></circle>
        <line class="cls-637b87aff95e86b59c57a1a5-1" x1="19.64" y1="12.07" x2="8.18" y2="12.07"></line>
        <line class="cls-637b87aff95e86b59c57a1a5-1" x1="12.95" y1="8.25" x2="12.95" y2="12.07"></line>
        <rect class="cls-637b87aff95e86b59c57a1a5-1" x="1.5" y="9.2" width="3.82" height="6.68" rx="1.91"></rect>
    </svg>

    <svg id="truckSVG" data-name="truckSVG" width="128pt" height="128pt" version="1.1" viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <path d="m118.4 60.289s-0.12891-5.8867-1.1523-7.5508c-1.0234-1.668-5.8867-4.0977-5.8867-4.0977s-0.51172-1.4062-3.1992-1.4062h-1.9219v-1.4062l-15.871-0.003906v1.4062l-28.031-0.12891h-19.328v-1.2812l-15.742 0.003907v1.2812h-16c-1.5352 0-3.7109 1.2812-3.7109 3.7109 0 1.4062-0.12891 2.1758-0.64063 3.5859-0.51562 1.1484-0.38672 2.1719-0.38672 3.1992v5.5039h-1.6641v3.0742h1.6641v5.5039c0 1.1523 0 2.1758 0.38281 3.1992 0.51172 1.2812 0.64062 2.1758 0.64062 3.5859 0 2.4336 2.3047 3.7109 3.7109 3.7109h16l0.003906 1.0195h15.871v-1.0234h19.328l28.031-0.12891v1.1523h15.742v-1.1523h1.9219c2.6875 0 3.1992-1.4062 3.1992-1.4062s4.8633-2.4336 5.8867-4.0977c1.0234-1.6641 1.1523-7.5508 1.1523-7.5508h0.64062v-8.707zm-60.285 2.0469h-46.336v-2.1758h46.336zm-0.12891-3.0703h-46.336v-2.1758h46.336zm-46.336-3.0742v-2.1758h14.336c0.76953 0.76953 1.6641 1.9219 2.9453 1.9219h11.137s1.6641 0.25781 3.457 0.25781zm46.336-3.0703h-9.3438c0.12891-0.76953 0.12891-1.5352 0-2.1758h9.3438zm0-3.5859v0.51172h-9.3438c0-0.25781-0.12891-0.51172-0.12891-0.51172zm-9.6016 4.4805h9.6016v2.1758h-14.207c1.5352 0 3.1992-0.25781 3.9688-0.89453 0.38281-0.25781 0.51172-0.76953 0.63672-1.2812zm-28.672-4.8633s0.25781 0.38281 0.64062 0.89453h-7.5508c2.3047-1.2773 6.9102-0.89453 6.9102-0.89453zm-7.8086 1.793h9.0898c0.25781 0.38281 0.51172 0.89453 0.64062 1.4062 0.12891 0.38281 0.38281 0.64063 0.64063 0.76953h-10.625v-1.2812c0-0.38281 0.12891-0.64062 0.25391-0.89453zm7.8086 29.312s-5.7617 0.38281-7.5508-1.4062h8.5742c-0.51172 0.89063-1.0234 1.4062-1.0234 1.4062zm1.9219-3.2031c-0.12891 0.25781-0.25781 0.64062-0.38281 0.89453l-9.6016 0.003906v-0.25781-1.793h13.824c-0.89844 0.25781-3.0742-0.63672-3.8398 1.1523zm36.352 2.8164h-9.4727s0.12891-0.38281 0.12891-1.0234h9.3438zm0-2.0469h-9.3438c0-0.64062 0-1.4062-0.12891-2.1758h9.4727zm0-3.0703h-9.8555c-0.12891-0.25781-0.25781-0.51172-0.51172-0.64062-1.5352-1.5352-7.6797-0.64062-7.6797-0.64062h-11.137c-1.0234 0-1.793 0.64062-2.4336 1.4062h-14.719v-2.1758h46.336zm0-3.0742h-46.336v-2.1758h46.336zm0-3.0703h-46.207v-2.1758h46.336zm0.12891-4.0977v1.0234h-46.336v-1.4062-0.76953h46.336zm4.9922 14.207c0 0.76953-0.64062 1.2812-1.2812 1.2812s-1.2812-0.64062-1.2812-1.2812v-28.285c0-0.76953 0.64062-1.2812 1.2812-1.2812s1.2812 0.64062 1.2812 1.2812zm16-7.293h-13.953v-1.6641h13.953zm0-11.906h-13.953v-1.6641h13.953zm17.277 6.7852h-0.38281c-0.38281 4.8633-1.5352 10.754-2.9453 13.184-1.6641 2.8164-10.113 2.0469-11.902 1.9219-1.793-0.12891 0-3.457 0.38281-6.5273 0.25781-2.0469 0.38281-6.0156 0.51172-8.4492h-0.51172v-4.2227h0.51172c-0.12891-2.5586-0.25781-5.8867-0.51172-7.6797-0.38281-3.0703-2.1758-6.3984-0.38281-6.5273 1.793-0.12891 10.238-0.89453 11.902 1.9219 1.2812 2.1758 2.4336 7.6797 2.8164 12.414h0.38281l0.003906 3.9648zm16.387 8.7031-16 2.9453v-1.0234l16.383-2.9453zm-16-22.656v-1.0234l16 2.9453 0.38281 1.0234z" fill="#fff"/>
    </svg>

    <script>
        // Show/hide controls and instructions based on device type
        function updateControlVisibility() {
            const isMobileDevice = isMobile();
            const snakeControls = document.getElementById('snakeControls');
            const desktopInstructions = document.getElementById('desktopInstructions');
            const gameCanvas = document.getElementById('gameCanvas');
            if (isMobileDevice) {
                if (snakeControls) snakeControls.style.display = 'flex';
                if (desktopInstructions) desktopInstructions.style.display = 'none';
            } else {
                if (snakeControls) snakeControls.style.display = 'none';
                if (desktopInstructions && gameCanvas) {
                    // Position desktopInstructions below the game canvas, centered
                    const rect = gameCanvas.getBoundingClientRect();
                    desktopInstructions.style.display = 'block';
                    desktopInstructions.style.top = (rect.bottom + 20 + window.scrollY) + 'px';
                    desktopInstructions.style.left = (rect.left + rect.width / 2 + window.scrollX) + 'px';
                    desktopInstructions.style.transform = 'translateX(-50%)';
                }
            }
        }
        window.addEventListener('resize', updateControlVisibility);
        window.addEventListener('scroll', updateControlVisibility);
        window.addEventListener('DOMContentLoaded', updateControlVisibility);
        const { createClient } = supabase
        const _supabase = createClient('https://qplxbyiotkuvsvganuhn.supabase.co', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFwbHhieWlvdGt1dnN2Z2FudWhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTEwNTkwMTUsImV4cCI6MjA2NjYzNTAxNX0.NM4YbUhQmlqw9ugOBEYQLgVSlg2gR3RE-sTQKRXGSvk')
        console.log('Supabase client created:', _supabase);
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const speedDisplay = document.getElementById('speedDisplay');
        const leaderboardList = document.getElementById('leaderboardList');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const snakeControlsButtonUp = document.getElementById('snakeControlsButtonUp');
        const snakeControls = document.getElementById('snakeControls');
        const snakeControlsButtonDown = document.getElementById('snakeControlsButtonDown');
        const snakeControlsButtonLeft = document.getElementById('snakeControlsButtonLeft');
        const snakeControlsButtonRight = document.getElementById('snakeControlsButtonRight');

        const gridSize = 20;
        const tileCount = canvas.width / gridSize;

let userName;
let snake, direction, food, gameOver, score, speed, interval;
let countdown = 0;
let countdownInterval = null;
let animProgress = 1;
let lastFrameTime = null;
let prevSnake = null;

// For the pop effect on the larger head
let headPopActive = false;
let headPopTimer = null;

let leaderboard = []; // Array to store leaderboard entries

// Explosion animation state
let explosionActive = false;
let explosionFrame = 0;
let explosionX = 0;
let explosionY = 0;
const EXPLOSION_FRAMES = 32;//24
const EXPLOSION_PARTICLES = 300;
let explosionParticles = [];

// Each truck is an object: { x, y, color }
function randomTruckColor() {
    // Pick a random color for the truck body
    const colors = ['#d15252', '#523f5c', '#fdff9e', '#e0e0e0', '#c29006', '#0c9ad6', '#a7876b', '#145460'];
    return colors[Math.floor(Math.random() * colors.length)];
}

function resetGame() {
    explosionActive = false;
    explosionFrame = 0;
    explosionParticles = [];
    document.getElementById('gameOverMessage').style.display = 'none';
    // Start with a single truck (the head)
    snake = [
        { x: 10, y: 10, color: '#749b7b' } // The player's truck is always MK green
    ];
    direction = { x: 1, y: 0 };
    food = generateFood();
    gameOver = false;
    score = 0;
    speed = 1;
    interval = 200;
    scoreDisplay.textContent = `Score: ${score}`;
    speedDisplay.textContent = `Speed: ${speed}`;
    restartButton.style.display = 'none';
    animProgress = 1;
    lastFrameTime = null;
    prevSnake = null;

}

function startGame() {
    //document.getElementById('leaderboard').style.color = 'white';
    //document.getElementById('leaderboard').style.backgroundColor = '#000000';
    //document.getElementById('leaderboard').style.opacity = 0.3;
    const leaderboardList = document.getElementById('leaderboardList');
    const leaderboardTitle = document.getElementById('leaderboardTitle');
    const leaderboard = document.getElementById('leaderboard');
    leaderboard.style.zIndex = 0;
    const gameCanvas = document.getElementById('gameCanvas');
    gameCanvas.style.zIndex = 1;

    leaderboard.style.opacity = '0.7';
    leaderboardList.style.opacity = '0.3';
    leaderboardTitle.style.opacity = '0.3';

    resetGame();
    startButton.style.display = 'none';
    countdown = 3;
    draw();
    countdownInterval = setInterval(() => {
        countdown--;
        draw();
        if (countdown === 0) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            animProgress = 1;
            lastFrameTime = null;
            prevSnake = null;
            requestAnimationFrame(frameLoop);
        }
    }, 1000);
}



        function isMobile() {
            // Basic mobile detection
            return window.innerWidth <= 700 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function positionDisplays() {
            // Place leaderboard directly behind the canvas and match its size/position
            const leaderboard = document.getElementById('leaderboard');
            const leaderboardList = document.getElementById('leaderboardList');
            const leaderboardTitle = document.getElementById('leaderboardTitle');
            const gameCanvas = document.getElementById('gameCanvas');
            if (gameCanvas && leaderboard) {
                const rect = gameCanvas.getBoundingClientRect();
                // Insert leaderboard before the canvas if not already
                if (gameCanvas.previousSibling !== leaderboard) {
                    gameCanvas.parentNode.insertBefore(leaderboard, gameCanvas);
                }
                leaderboard.style.position = 'absolute';
                leaderboard.style.left = rect.left + window.scrollX + 'px';
                leaderboard.style.top = rect.top + window.scrollY + 'px';
                leaderboard.style.width = rect.width + 'px';
                leaderboard.style.height = rect.height + 'px';
                leaderboard.style.zIndex = '0';
                leaderboard.style.opacity = '0.7';
                leaderboard.style.pointerEvents = 'none';
                leaderboard.style.textAlign = 'center';
                leaderboard.style.display = 'block';
                leaderboard.style.background = '#f2ede2'; // Match the canvas background

                leaderboardList.style.opacity = '1';
                leaderboardTitle.style.opacity = '1';
            }
            const gap = 20;
            const isMobileDevice = isMobile();
            // Center authModal over the game canvas on mobile
            const authModal = document.getElementById('authModal');
            
            if (isMobileDevice && authModal && gameCanvas) {
                console.log('Positioning auth modal for mobile');
                // Get canvas position and size
                const rect = gameCanvas.getBoundingClientRect();
                // Center modal over canvas
                authModal.style.position = 'absolute';
                authModal.style.left = (rect.left + rect.width / 2 + window.scrollX) + 'px';
                authModal.style.top = (rect.top + rect.height / 2 + window.scrollY) + 'px';
                authModal.style.transform = 'translate(-50%, -50%)';
                authModal.style.zIndex = '1000';
            } else if (authModal) {
                // Restore default (fixed, centered in viewport)
                authModal.style.position = 'fixed';
                authModal.style.left = '50%';
                authModal.style.top = '50%';
                authModal.style.transform = 'translate(-50%, -50%)';
                authModal.style.zIndex = '1000';
            }

            // Position start and restart buttons 20px above the bottom of the game canvas, centered horizontally, and ensure they are within the canvas
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            const gameOverMessage = document.getElementById('gameOverMessage');
            if (gameCanvas) {
                const rect = gameCanvas.getBoundingClientRect();
                // Calculate button width and height (fallback to 120x40 if not rendered yet)
                const buttonWidth = (startButton && startButton.offsetWidth) ? startButton.offsetWidth : 120;
                const buttonHeight = (startButton && startButton.offsetHeight) ? startButton.offsetHeight : 40;
                // Y position: 20px above the bottom, but not below the canvas
                const buttonY = rect.top + rect.height - 20 - buttonHeight + window.scrollY;
                // X position: center within the canvas
                const buttonX = rect.left + rect.width / 2 + window.scrollX;
                // Place start button
                if (startButton) {
                    startButton.style.position = 'absolute';
                    startButton.style.left = buttonX + 'px';
                    startButton.style.top = buttonY + 'px';
                    startButton.style.transform = 'translate(-50%, 0)';
                    startButton.style.zIndex = '1001';
                    // Ensure button is a child of the canvas's parent (so it overlays the canvas)
                    if (gameCanvas.parentNode && startButton.parentNode !== gameCanvas.parentNode) {
                        gameCanvas.parentNode.appendChild(startButton);
                    }
                }
                // Place restart button
                if (restartButton) {
                    restartButton.style.position = 'absolute';
                    restartButton.style.left = buttonX + 'px';
                    restartButton.style.top = buttonY + 'px';
                    restartButton.style.transform = 'translate(-50%, 0)';
                    restartButton.style.zIndex = '1001';
                    if (gameCanvas.parentNode && restartButton.parentNode !== gameCanvas.parentNode) {
                        gameCanvas.parentNode.appendChild(restartButton);
                    }
                }

                if (gameOverMessage) {
                    // Position game over message centered over the canvas
                    gameOverMessage.style.position = 'absolute';
                    gameOverMessage.style.left = (rect.left + rect.width / 2 + window.scrollX) + 'px';
                    gameOverMessage.style.top = (rect.top + rect.height / 2 + window.scrollY) + 'px';
                    gameOverMessage.style.transform = 'translate(-50%, -50%)';
                    gameOverMessage.style.zIndex = '1001';
                }
            }
            const canvasRect = canvas.getBoundingClientRect();

            if (isMobileDevice) {
                //console.log('Positioning displays for mobile');
                const gameTitle = document.getElementById('gameTitle');
                // Position gameTitle at the top of the screen
                if (gameTitle) {
                    gameTitle.style.position = 'absolute';
                    gameTitle.style.top = `${gap}px`; // Place at the very top
                    gameTitle.style.left = '50%';
                    gameTitle.style.transform = 'translateX(-50%)';
                }

                const spacingBetweenScoreAndSpeed = 50; // Specific gap between score and speed


                // Center score and speed horizontally below the gameTitle
                if (scoreDisplay && speedDisplay) {
                    scoreDisplay.style.position = 'absolute';
                    speedDisplay.style.position = 'absolute';

                    const scoreW = scoreDisplay.offsetWidth || 80;
                    const speedW = speedDisplay.offsetWidth || 80;
                    const totalW = scoreW + speedW + spacingBetweenScoreAndSpeed;
                    const centerX = window.innerWidth / 2;

                    const scoreTop = gap + gameTitle.offsetHeight + gap;
                    scoreDisplay.style.top = `${scoreTop}px`;
                    scoreDisplay.style.left = `${centerX - totalW / 2}px`;

                    const speedTop = scoreTop;
                    speedDisplay.style.top = `${speedTop}px`;
                    speedDisplay.style.left = `${centerX - totalW / 2 + scoreW + spacingBetweenScoreAndSpeed}px`;
                }

                const gameCanvas = document.getElementById('gameCanvas');

                // Move the game canvas below the score and speed displays
                if (gameCanvas) {
                    const canvasTop = gap + gameTitle.offsetHeight + gap + scoreDisplay.offsetHeight + gap;
                    gameCanvas.style.position = 'absolute';
                    gameCanvas.style.top = `${canvasTop}px`;
                    gameCanvas.style.left = '50%';
                    gameCanvas.style.transform = 'translateX(-50%)';
                }

                // Controls: just below the game canvas, centered
                /*if (snakeControls && gameCanvas) {
                    snakeControls.style.position = 'absolute';
                    snakeControls.style.top = `${canvasTop + gameCanvas.offsetHeight + gap}px`;
                    snakeControls.style.left = '50vw';
                    snakeControls.style.transform = 'translateX(-50%)';
                }*/

                if (gameCanvas && snakeControls) {
                    const rect = gameCanvas.getBoundingClientRect();

                    // Position snakeControls below the gameCanvas
                    snakeControls.style.position = 'absolute';
                    snakeControls.style.top = `${rect.bottom + gap + window.scrollY}px`; // Place below the canvas with a gap
                    snakeControls.style.left = `${rect.left + rect.width / 2 + window.scrollX}px`; // Center horizontally
                    snakeControls.style.transform = 'translateX(-50%)'; // Adjust for centering
                    snakeControls.style.display = 'flex'; // Ensure controls are visible
                }

                // Leaderboard: handled above, always placed behind the canvas and sized to match
            }
            else {

                const gap = 10;

                // Desktop: center score and speed horizontally just above the game canvas with a 50px gap
                
                // Calculate widths (fallback if not rendered yet)
                const scoreW = scoreDisplay.offsetWidth || 80;
                const speedW = speedDisplay.offsetWidth || 80;
                const totalW = scoreW + speedW + 50;
                // Get the canvas position
                const canvasRect = canvas.getBoundingClientRect();
                //const centerX = canvasRect.left + canvasRect.width / 2 + window.scrollX;
                const centerX = canvasRect.left + canvasRect.width / 2;
                
                // Place both displays just above the canvas
                //const displaysTop = canvasRect.top - (scoreDisplay.offsetHeight || 20) - gap + window.scrollY;
                const displaysTop = canvasRect.top - (scoreDisplay.offsetHeight || 20) - gap;

                
                // Score: left of center
                scoreDisplay.style.position = 'absolute';
                scoreDisplay.style.top = `${displaysTop}px`;
                scoreDisplay.style.left = `${centerX - totalW/2}px`;
                // Speed: right of score, with 50px gap
                speedDisplay.style.position = 'absolute';
                speedDisplay.style.top = `${displaysTop}px`;
                speedDisplay.style.left = `${centerX - totalW/2 + scoreW + 50}px`;

                const gameTitle = document.getElementById('gameTitle');
                const titleGap = displaysTop - 100;//Place the game title 100px above the score/speed displays

                // Position gameTitle at the top of the screen
                if (gameTitle) {
                    gameTitle.style.position = 'absolute';
                    gameTitle.style.top = `${titleGap}px`; // Place at the very top
                    gameTitle.style.left = '50%';
                    gameTitle.style.transform = 'translateX(-50%)';
                }

                // Controls: just below the canvas, centered
                if (snakeControls) {
                    snakeControls.style.position = 'absolute';
                    snakeControls.style.top = `${canvasRect.bottom + 20 + window.scrollY}px`;
                    snakeControls.style.left = `${canvasRect.left + canvasRect.width / 2 + window.scrollX}px`;
                    snakeControls.style.transform = 'translateX(-50%)';
                }

                // Leaderboard: handled above, always placed behind the canvas and sized to match
            }
        }
        

        window.addEventListener('resize', positionDisplays); // Reposition on window resize
        window.addEventListener('scroll', positionDisplays); // Reposition on scroll (for mobile)

        // Ensure all elements are rendered and styled before initial positioning
        window.addEventListener('DOMContentLoaded', () => {
            // Use a longer timeout and multiple calls to ensure layout is correct on mobile
            setTimeout(positionDisplays, 100);
            setTimeout(positionDisplays, 300);
            setTimeout(positionDisplays, 600);
            // Also call after all resources (images/fonts) are loaded
            window.addEventListener('load', () => {
                setTimeout(positionDisplays, 100);
                setTimeout(positionDisplays, 300);
                setTimeout(positionDisplays, 600);
            });
        });

function generateFood() {
    let newFood;
    let head = snake[0];
    // Predict the next head position
    let nextHead = { x: head.x + direction.x, y: head.y + direction.y };
    do {
        newFood = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount), color: randomTruckColor() };
    } while (
        snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
        (nextHead.x === newFood.x && nextHead.y === newFood.y)
    );
    return newFood;
}


        let floatingText = null; // Store the floating text object
let floatingTextTimer = null; // Timer to remove the floating text

function drawFloatingText() {
    if (!floatingText) return;

    const { x, y, opacity } = floatingText;

    ctx.save();
    ctx.globalAlpha = opacity; // Set transparency

    // Draw white outline
    ctx.strokeStyle = '#f2ede2';
    ctx.lineWidth = 5;
    ctx.font = '20px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.strokeText('+1', x, y);

    // Draw purple fill
    ctx.fillStyle = '#5b9472';
    ctx.fillText('+1', x, y);

    ctx.restore();
}

function updateFloatingText() {
    if (!floatingText) return;

    // Smoothly move the text upward using interpolation
    floatingText.progress += 0.1; // Increment progress (adjust speed as needed)

    // Interpolate position based on progress
    floatingText.y = floatingText.startY + (floatingText.targetY - floatingText.startY) * floatingText.progress;

    // Fade out the text based on progress
    floatingText.opacity = 1.0 - floatingText.progress;

    // Remove the floating text when it reaches the target or becomes invisible
    if (floatingText.progress >= 1.0) {
        floatingText = null;
        clearTimeout(floatingTextTimer);
    }
}

// Draw a truck as a top view: colored rectangle, white cab at the front, and four wheels at the corners
function drawTruck(x, y, color, angle = 0) {
    const px = x * gridSize;
    const py = y * gridSize;

    ctx.save();
    ctx.translate(px + gridSize / 2, py + gridSize / 2);
    // Always orient the cab/windshield to the right (0 radians)
    ctx.rotate(angle);
    ctx.translate(-gridSize / 2, -gridSize / 2);


    // --- Define bodyX/bodyY/bodyW/bodyH before using them ---
    const bodyW = gridSize * 0.9;
    const bodyH = gridSize * 0.55;
    const bodyX = (gridSize - bodyW) / 2;
    const bodyY = (gridSize - bodyH) / 2;

    // --- Draw tires: black squares at each corner, sticking out and UNDER the body ---
    ctx.save();
    ctx.fillStyle = '#111';
    const tireSize = gridSize * 0.25;
    const offset = tireSize * 0.5;
    // Top left
    ctx.fillRect(bodyX - offset  + 4, bodyY - offset, tireSize, tireSize);
    // Top right (move left 5px)
    ctx.fillRect(bodyX + bodyW - tireSize + offset - 5, bodyY - offset, tireSize, tireSize);
    // Bottom left
    ctx.fillRect(bodyX - offset + 4, bodyY + bodyH - tireSize + offset, tireSize, tireSize);
    // Bottom right (move left 5px)
    ctx.fillRect(bodyX + bodyW - tireSize + offset - 5, bodyY + bodyH - tireSize + offset, tireSize, tireSize);
    ctx.restore();


    // --- Draw main rectangle body ON TOP of the tires, with rounded top right and bottom right corners ---
    ctx.save();
    ctx.globalAlpha = 1.0; // Ensure fully opaque
    ctx.fillStyle = color;
    ctx.strokeStyle = shadeColor(color, -40);
    ctx.lineWidth = 2;
    const r = Math.min(bodyW, bodyH) * 0.25; // radius for right corners
    ctx.beginPath();
    ctx.moveTo(bodyX, bodyY); // top left
    ctx.lineTo(bodyX + bodyW - r, bodyY); // top edge to before top right
    ctx.quadraticCurveTo(bodyX + bodyW, bodyY, bodyX + bodyW, bodyY + r); // round top right
    ctx.lineTo(bodyX + bodyW, bodyY + bodyH - r); // right edge
    ctx.quadraticCurveTo(bodyX + bodyW, bodyY + bodyH, bodyX + bodyW - r, bodyY + bodyH); // round bottom right
    ctx.lineTo(bodyX, bodyY + bodyH); // bottom edge
    ctx.lineTo(bodyX, bodyY); // left edge
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // --- Draw truck bed: 7px wide, 5px tall rectangle at the rear (left) of the truck, ON TOP of the body ---
    ctx.save();
    ctx.globalAlpha = 1.0; // Ensure fully opaque
    ctx.fillStyle = shadeColor(color, -40); // Use the same color as the body stroke
    const bedW = 7;
    const bedH = 8;
    const bedX = bodyX - 2; // Slightly outside the left edge of the body
    const bedY = bodyY + (bodyH - bedH) / 2;
    ctx.fillRect(bedX, bedY, bedW, bedH);
    ctx.restore();

    // --- Draw cab: stroked square in the middle of the truck body ---
    ctx.save();
    ctx.globalAlpha = 1.0; // Ensure fully opaque
    const cabSize = Math.min(bodyW, bodyH) * 0.5;
    const cabX = bodyX + (bodyW - cabSize) / 2;
    const cabY = bodyY + (bodyH - cabSize) / 2;
    ctx.strokeStyle = shadeColor(color, -40);
    ctx.lineWidth = 2;
    ctx.strokeRect(cabX, cabY, cabSize, cabSize);
    ctx.restore();

    ctx.restore();
}

// Helper: draw a rounded rectangle
function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
}

// Helper: lighten/darken color by percent
function shadeColor(color, percent) {
    // color: #rrggbb
    let R = parseInt(color.substring(1,3),16);
    let G = parseInt(color.substring(3,5),16);
    let B = parseInt(color.substring(5,7),16);
    R = Math.min(255, Math.max(0, R + Math.round(2.55 * percent)));
    G = Math.min(255, Math.max(0, G + Math.round(2.55 * percent)));
    B = Math.min(255, Math.max(0, B + Math.round(2.55 * percent)));
    return `#${(R.toString(16)).padStart(2,'0')}${(G.toString(16)).padStart(2,'0')}${(B.toString(16)).padStart(2,'0')}`;
}

// Helper to get angle for truck based on direction (no mirroring)
function getTruckDrawAngle(dir) {
    // Truck points right by default
    if (dir.x === 1 && dir.y === 0) return 0; // right
    if (dir.x === 0 && dir.y === -1) return -Math.PI / 2; // up
    if (dir.x === 0 && dir.y === 1) return Math.PI / 2; // down
    if (dir.x === -1 && dir.y === 0) return Math.PI; // left
    return 0;
}

        function draw() {
            // Clear the canvas every frame to prevent streaks
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw countdown if active
            if (countdown > 0) {
                ctx.fillStyle = '#5b9472'; // MK green
                ctx.font = `${Math.floor(canvas.width * 0.8)}px 'Press Start 2P', sans-serif`;
                ctx.shadowColor = '#000000'; // black shadow
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 4;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = 0.85;
                ctx.fillText(countdown, canvas.width / 2, canvas.height / 2);
                ctx.shadowColor = 'transparent'; // clear the shadow
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.globalAlpha = 1.0;
                return;
            }




            // Draw the food truck only if it is not hidden by the snake's head
            if (!(snake[0].x === food.x && snake[0].y === food.y)) {
                drawTruck(food.x, food.y, food.color, 0);
            }

            // Draw all trucks in the snake (head + collected trucks)
            const spacing = 0; // space between trucks in grid units (0.18*gridSize ~ 3.6px if gridSize=20)
            for (let i = 0; i < snake.length; i++) {
                let seg = snake[i];
                let prevSeg = prevSnake && prevSnake[i] ? prevSnake[i] : seg;
                // Interpolate position for smooth movement
                let x = (prevSeg.x + (seg.x - prevSeg.x) * animProgress);
                let y = (prevSeg.y + (seg.y - prevSeg.y) * animProgress);
                // Offset each truck by spacing * its index, in the direction opposite to its movement
                let angle = 0;
                let offsetX = 0, offsetY = 0;
                if (i === 0) {
                    angle = getTruckDrawAngle(direction);
                    offsetX = -direction.x * spacing * i;
                    offsetY = -direction.y * spacing * i;
                } else {
                    let prev = snake[i - 1];
                    let dx = prev.x - seg.x;
                    let dy = prev.y - seg.y;
                    angle = getTruckDrawAngle({ x: dx, y: dy });
                    // Normalize dx/dy to -1,0,1
                    if (dx !== 0) dx = dx > 0 ? 1 : -1;
                    if (dy !== 0) dy = dy > 0 ? 1 : -1;
                    offsetX = -dx * spacing * i;
                    offsetY = -dy * spacing * i;
                }
                drawTruck(x + offsetX, y + offsetY, seg.color, angle);
            }

            // Draw floating text
            drawFloatingText();



            // If game over, overlay game over text and submit score
            if (gameOver) {
                triggerExplosion();
                // Draw explosion animation if active (always draw on top of trucks)
                if (explosionActive) {
                    updateExplosion();
                    drawExplosion();
                    setTimeout(() => {
                        //explosionActive = false; // Stop explosion after last frame
                        finishGame(); // Show game over screen
                    }, 2000); // Wait 2 seconds before finishing the game
                }

                function finishGame(){
                    const leaderboard = document.getElementById('leaderboard');
                    const leaderboardList = document.getElementById('leaderboardList');
                    const leaderboardTitle = document.getElementById('leaderboardTitle');
                    const gameOverMessage = document.getElementById('gameOverMessage');
                    const gameCanvas = document.getElementById('gameCanvas');

                    gameCanvas.style.zIndex = '0'; // Move canvas behind leaderboard

                    leaderboard.style.zIndex = '1';
                    leaderboard.style.opacity = '0.7';
                    leaderboardList.style.opacity = '1';
                    leaderboardTitle.style.opacity = '1';
                    gameOverMessage.style.display = 'block';
                    gameOverMessage.style.zIndex = '2';
                    submitScore(score);
                    restartButton.style.display = 'block';
                }


                return;
            }
        }

        async function fetchLeaderboard() {
            const { data, error } = await _supabase
                .from('leaderboard')
                .select('name, score')
                .order('score', { ascending: false })
                .limit(10);

            if (error) {
                console.error('Error fetching leaderboard:', error);
                return [];
            }

            return data;
        }

        async function submitScore(score) {
            const { data: { user } } = await _supabase.auth.getUser();
            if (!user) {
                console.error('Error fetching user:', error);
                return;
            }
            //console.log("user.user_metadata: ", user);
            //const name = "TEST"; // Default name for testing purposes
            //const name = user.user_metadata.name; // Get the user's name from metadata
            const { error: insertError } = await _supabase
                .from('leaderboard')
                .insert({ score: score, name: userName, memid: user.id })
                .select();

            if (insertError) {
                console.error('Error submitting score:', insertError);
            } else {
                updateLeaderboardUI(); // Refresh leaderboard after submission
            }
        }

        async function updateLeaderboardUI() {
            const leaderboard = await fetchLeaderboard();
            leaderboardList.innerHTML = ''; // Clear existing leaderboard
            leaderboard.forEach(entry => {
                const li = document.createElement('li');
                li.textContent = `${entry.name}: ${entry.score}`;
                leaderboardList.appendChild(li);
            });
        }

        function update() {
            if (gameOver) return;

            // Move the snake's head forward first
            let newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y, color: snake[0].color };

            // Check for collision (wall or self)
            if (
                newHead.x < 0 ||
                newHead.x >= tileCount ||
                newHead.y < 0 ||
                newHead.y >= tileCount ||
                snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)
            ) {
                gameOver = true;
                // Trigger explosion at head position
                explosionActive = true;
                explosionFrame = 0;
                explosionX = newHead.x * gridSize + gridSize / 2;
                explosionY = newHead.y * gridSize + gridSize / 2;
                explosionParticles = [];
                // Use the current truck color for explosion particles, with variations
                const baseColor = snake[0]?.color || '#d15252';
                function shadeColorExplosion(color, percent) {
                    let R = parseInt(color.substring(1,3),16);
                    let G = parseInt(color.substring(3,5),16);
                    let B = parseInt(color.substring(5,7),16);
                    R = Math.min(255, Math.max(0, R + Math.round(2.55 * percent)));
                    G = Math.min(255, Math.max(0, G + Math.round(2.55 * percent)));
                    B = Math.min(255, Math.max(0, B + Math.round(2.55 * percent)));
                    return `#${(R.toString(16)).padStart(2,'0')}${(G.toString(16)).padStart(2,'0')}${(B.toString(16)).padStart(2,'0')}`;
                }
                // Calculate max speed so particles can reach the canvas edge
                const maxCanvasDist = Math.max(canvas.width, canvas.height);
                //const maxCanvasDist = Math.max(canvas.width, canvas.height) / 2;
                for (let i = 0; i < EXPLOSION_PARTICLES; i++) {
                    const angle = (2 * Math.PI * i) / EXPLOSION_PARTICLES;
                    // Speed so that in EXPLOSION_FRAMES, the particle travels to the edge
                    const speed = maxCanvasDist / (EXPLOSION_FRAMES * 0.92) * (0.92 + Math.random() * 0.15); // add a little variation
                    // Particle color: random shade variation of the truck color
                    const shade = -40 + Math.random() * 80; // -40 to +40 percent
                    const color = shadeColorExplosion(baseColor, shade);
                    explosionParticles.push({
                        x: explosionX,
                        y: explosionY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: 32 + Math.random() * 24, // Much chunkier particles
                        color: color,
                        alpha: 1
                    });
                }
                console.log('explosionParticles.push: ',explosionParticles);
                return;
            }


            prevSnake = snake.map(seg => ({ ...seg }));
            snake.unshift(newHead); // Add new head

            // Check if food is eaten
            if (newHead.x === food.x && newHead.y === food.y) {
                // Change head color to food color
                snake[0].color = food.color;

                // Generate new food
                food = generateFood();
                score++;
                scoreDisplay.textContent = `Score: ${score}`;

                // Activate the floating text from the snake's head position
                floatingText = {
                    startX: newHead.x * gridSize + gridSize / 2,
                    startY: newHead.y * gridSize + gridSize / 2,
                    targetY: newHead.y * gridSize - gridSize * 2,
                    x: newHead.x * gridSize + gridSize / 2,
                    y: newHead.y * gridSize + gridSize / 2,
                    opacity: 1.0,
                    progress: 0.0,
                };

                // Remove the floating text after 3 seconds (fallback)
                if (floatingTextTimer) clearTimeout(floatingTextTimer);
                floatingTextTimer = setTimeout(() => {
                    floatingText = null;
                }, 3000);

                if (score % 10 === 0) {
                    interval = Math.max(50, interval - 8);
                    speed++;
                    speedDisplay.textContent = `Speed: ${speed}`;
                }
                // Do not remove tail (snake grows)
            } else {
                // Remove the tail if no food is eaten
                snake.pop();
            }

            animProgress = 0;
            updateFloatingText(); // Update floating text position and opacity
        }


        function frameLoop(timestamp) {
            if (lastFrameTime === null) lastFrameTime = timestamp;
            let dt = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            let moveTime = interval;
            if (gameOver || countdown > 0) {
                draw();
                // Animate explosion if active
                if (explosionActive) {
                    console.log('Explosion active. Triggering updateExplosion')
                    explosionFrame++;
                    updateExplosion();
                    drawExplosion(); // Ensure particles are drawn
                    if (explosionFrame < EXPLOSION_FRAMES) {
                        requestAnimationFrame(frameLoop);
                    } else {
                        explosionActive = false;
                    }
                }
                return;
            }
            animProgress += dt / moveTime;
            if (animProgress >= 1) {
                animProgress = 1;
                update();
            }
            draw();
            if (!gameOver) requestAnimationFrame(frameLoop);
        }

// Explosion animation using GIF
let explosionGif = null;
let explosionGifLoaded = false;
let explosionGifFrame = 0;
let explosionGifTotalFrames = 24; // Adjust if your GIF has a different frame count
let explosionGifDuration = 1000; // ms
let explosionGifStartTime = null;

function preloadExplosionGif() {
    explosionGif = new Image();
    explosionGif.src = 'data:image/png;base64,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';
    explosionGif.onload = () => { explosionGifLoaded = true; };
}
preloadExplosionGif();

// Draw explosions for all trucks in the convoy on game over
function drawExplosion() {
    if (!explosionGifLoaded) return;
    // Calculate frame based on time
    let now = performance.now();
    if (!explosionGifStartTime) explosionGifStartTime = now;
    let elapsed = now - explosionGifStartTime;
    let frame = Math.floor((elapsed / explosionGifDuration) * explosionGifTotalFrames);
    if (frame >= explosionGifTotalFrames) frame = explosionGifTotalFrames - 1;

    ctx.save();
    ctx.globalAlpha = 1.0;

    // Draw explosion for each truck in the convoy
    for (let i = 0; i < snake.length; i++) {
        let seg = snake[i];
        let px = seg.x * gridSize + gridSize / 2;
        let py = seg.y * gridSize + gridSize / 2;
        if (i === 0) {
            // Head truck: big explosion (current size)
            let size = canvas.width * 0.3;
            ctx.drawImage(explosionGif, px - size/2, py - size/2, size, size);
        } else {
            // Convoy trucks explosion
            setTimeout(() => {
                let size = 40;
                ctx.drawImage(explosionGif, px - size/2, py - size/2, size, size);
            }, i * 100); // Stagger explosions by 100ms per truck

        }
    }
    ctx.restore();
}

function updateExplosion() {
    // No-op for GIF
}

        startButton.addEventListener('click', () => {
            startGame();
            updateLeaderboardUI();
        });
        restartButton.addEventListener('click', startGame); // Add event listener to restart button

        window.addEventListener('keydown', e => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y === 0) direction = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y === 0) direction = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x === 0) direction = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x === 0) direction = { x: 1, y: 0 };
                    break;
            }
        });

        // Touch/click controls for mobile and desktop
        snakeControlsButtonUp.addEventListener('touchstart', e => { e.preventDefault(); if (direction.y === 0) direction = { x: 0, y: -1 }; });
        snakeControlsButtonDown.addEventListener('touchstart', e => { e.preventDefault(); if (direction.y === 0) direction = { x: 0, y: 1 }; });
        snakeControlsButtonLeft.addEventListener('touchstart', e => { e.preventDefault(); if (direction.x === 0) direction = { x: -1, y: 0 }; });
        snakeControlsButtonRight.addEventListener('touchstart', e => { e.preventDefault(); if (direction.x === 0) direction = { x: 1, y: 0 }; });

        snakeControlsButtonUp.addEventListener('click', () => { if (direction.y === 0) direction = { x: 0, y: -1 }; });
        snakeControlsButtonDown.addEventListener('click', () => { if (direction.y === 0) direction = { x: 0, y: 1 }; });
        snakeControlsButtonLeft.addEventListener('click', () => { if (direction.x === 0) direction = { x: -1, y: 0 }; });
        snakeControlsButtonRight.addEventListener('click', () => { if (direction.x === 0) direction = { x: 1, y: 0 }; });

        async function subscribeToLeaderboard() {

            const changes = _supabase
            .channel('table-db-changes')
            .on(
                'postgres_changes',
                {
                event: 'INSERT',
                schema: 'public',
                table: 'leaderboard',
                },
                (payload) => updateLeaderboardUI()
            )
            .subscribe()
        }
        subscribeToLeaderboard(); // Initial fetch of leaderboard

        const authModal = document.getElementById('authModal');
        const authForm = document.getElementById('authForm');
        let emailInput = document.getElementById('email');
        //const toggleAuthMode = document.getElementById('toggleAuthMode');
        const authModalTitle = document.getElementById('authModalTitle');

        let isSignUpMode = false; // Tracks whether the modal is in sign-up or login mode

        async function checkAuth() {
            const { data: { user } } = await _supabase.auth.getUser();
            if (!user) {
                // Show the modal if the user is not signed in
                authModal.style.display = 'block';
                if (startButton) startButton.style.display = 'none';
            } else {
                console.log('User is signed in:', user);

                const userid = user.id;

                const { data, error } = await _supabase
                .from('userdata')
                .select('name');

                if (error) {
                    alert('Error fetching user data: ' + error.message);
                }
                else{
                    console.log('User data:', data);
                    if (data.length > 0) {
                        const userData = data[0];
                        // You can display the user's name or any other data as needed
                        if (userData.name) {
                            console.log('User name:', userData.name);
                            userName = userData.name; // Store the user's name
                            authModal.style.display = 'none'; // Hide the modal
                            if (startButton) startButton.style.display = 'block'; // Allow the user to start the game
                        } else {
                            console.log('No name found for this user.');
                            // Optionally, you can prompt the user to enter their name
                            authModal.style.display = 'block'; // Show the modal to enter name
                            authModalTitle.textContent = 'Enter Your Name';
                            authForm.innerHTML = `
                                <input type="text" id="name" placeholder="Name" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                                <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
                            `;
                            authForm.addEventListener('submit', async (e) => {
                                e.preventDefault();
                                const name = document.getElementById('name').value;
                                if (!name) {
                                    alert('Please enter your name.');
                                    return;
                                }

                                const { data, error } = await _supabase
                                .from('userdata')
                                .insert({ memid: userid, name: name})
                                .select()

                                if (error) {
                                    console.error('Error updating user data:', error.message);
                                    alert('Error: ' + error.message);
                                } else {
                                    console.log('User data updated successfully:', name);
                                    authModal.style.display = 'none'; // Hide the modal after successful update
                                    checkAuth(); // Recheck authentication
                                }
                            });
                        }
                        if (startButton) startButton.style.display = 'block'; // Allow the user to start the game
                        if (restartButton) restartButton.style.display = 'block'; // Allow the user to restart the game
                        updateLeaderboardUI(); // Update the leaderboard UI     
                    } 
                    else {
                        console.log('No user data found for this user.');
                        authModal.style.display = 'block'; // Show the modal to enter name
                        authModalTitle.textContent = 'Enter Your Name';
                        authForm.innerHTML = `
                            <input type="text" id="name" placeholder="Name" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                            <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
                        `;
                        authForm.addEventListener('submit', async (e) => {
                            e.preventDefault();
                            const name = document.getElementById('name').value;
                            if (!name) {
                                alert('Please enter your name.');
                                return;
                            }

                            const { data, error } = await _supabase
                            .from('userdata')
                            .insert({ memid: userid, name: name})
                            .select()

                            if (error) {
                                console.error('Error updating user data:', error.message);
                                alert('Error: ' + error.message);
                            } else {
                                console.log('User data updated successfully:', name);
                                authModal.style.display = 'none'; // Hide the modal after successful update
                                checkAuth(); // Recheck authentication
                            }
                        });
                    }
                }
            }
        }

        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            emailInput = document.getElementById('email');
            const email = emailInput.value;

            if (isSignUpMode) {
                // Sign-up logic
                console.log('Submitting magic link for email:', email);
                const { data, error } = await _supabase.auth.signInWithOtp({
                    email: email,
                    options: {
                        // set this to false if you do not want the user to be automatically signed up
                        //shouldCreateUser: false,
                        emailRedirectTo: 'https://mapkind.github.io/convoy',
                    },
                })
                if(!error){
                    console.log('User signed up:', data);
                    alert('Sign-up successful! Please check your email for the magic link.');
                    // Hide the modal after successful sign-up
                    authModal.style.display = 'none'; // Hide the modal after successful sign-up
                    checkAuth(); // Recheck authentication
                }
                else{
                    console.error('Error signing up:', error.message);
                    alert('Error: ' + error.message);
                    return;
                }
            } 
            else {
                console.log('Submitting magic link for email:', email);
                // Magic link sign-in logic
                const { error } = await _supabase.auth.signInWithOtp({
                    email: email,
                    options: {
                        //data: { name },
                        // set this to false if you do not want the user to be automatically signed up
                        //shouldCreateUser: false,
                        emailRedirectTo: 'https://mapkind.github.io/convoy',
                    },
                });

                if (error) {
                    console.error('Error sending magic link:', error.message);
                    alert('Error: ' + error.message);
                } else {
                    alert('Magic link sent! Check your email to log in.');
                }
            }
        });

        /*toggleAuthMode.addEventListener('click', (e) => {
            e.preventDefault();
            isSignUpMode = !isSignUpMode;
            toggleAuthMode.textContent = isSignUpMode ? 'Already a user? Log in here.' : 'Not a user? Sign up here.';
            authModalTitle.textContent = isSignUpMode ? 'Sign Up' : 'Log In';
            authForm.innerHTML = isSignUpMode
                ? `
                    <input type="email" id="email" placeholder="Email" required style="display: block; margin-bottom: 10px; width: 100%; padding: 10px;">
                    <button type="submit" style="padding: 10px 20px; font-size: 16px;">Sign Up</button>
                `
                : `
                    <input type="email" id="email" placeholder="Email" required style="display: block; margin-bottom:  10px; width: 100%; padding: 10px;">
                    <button type="submit" style="padding: 10px 20px; font-size: 16px;">Submit</button>
                `;
        });*/

        startButton.addEventListener('click', async () => {
            const { data: { user } } = await _supabase.auth.getUser();
            if (!user) {
                alert('You must be signed in to play the game.');
                authModal.style.display = 'block';
            } else {
                startGame();
            }
        });

        // Check authentication on page load
        checkAuth();

        let truckImage = null;

function preloadTruckImage() {
    const truckSVG = document.getElementById('truckSVG');
    const svgData = new XMLSerializer().serializeToString(truckSVG);
    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);

    truckImage = new Image();
    truckImage.src = url;

    truckImage.onload = () => {
        console.log('Truck image preloaded successfully.');
        URL.revokeObjectURL(url); // Release the URL object
    };
}

preloadTruckImage();

function initializeExplosionParticles() {
    const maxCanvasDist = Math.max(canvas.width, canvas.height); // Maximum distance across the canvas
    const baseColor = snake[0]?.color || '#d15252'; // Use the head truck's color as the base

    explosionParticles = [];
    for (let i = 0; i < EXPLOSION_PARTICLES; i++) {
        const angle = (2 * Math.PI * i) / EXPLOSION_PARTICLES; // Spread particles evenly in all directions
        const speed = maxCanvasDist / EXPLOSION_FRAMES * (1.5 + Math.random() * 0.5); // Increase base speed and add random variation
        const shade = -40 + Math.random() * 80; // Random shade variation
        const color = shadeColorExplosion(baseColor, shade);

        explosionParticles.push({
            x: explosionX,
            y: explosionY,
            vx: Math.cos(angle) * speed, // Horizontal velocity
            vy: Math.sin(angle) * speed, // Vertical velocity
            color: color,
            alpha: 1 // Start fully opaque
        });

        function shadeColorExplosion(color, percent) {
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);
            R = Math.min(255, Math.max(0, R + Math.round(2.55 * percent)));
            G = Math.min(255, Math.max(0, G + Math.round(2.55 * percent)));
            B = Math.min(255, Math.max(0, B + Math.round(2.55 * percent)));
            return `#${(R.toString(16)).padStart(2,'0')}${(G.toString(16)).padStart(2,'0')}${(B.toString(16)).padStart(2,'0')}`;
        }
    }
}

function triggerExplosion() {
    explosionActive = true;
    explosionFrame = 0;
    explosionX = snake[0].x * gridSize + gridSize / 2; // Center of the head truck
    explosionY = snake[0].y * gridSize + gridSize / 2;
    initializeExplosionParticles();
}
    </script>
</body>
</html>
